OFFICE-JS-ADD-IN-DESIGN-APPROACH

# Office.js Add-in Alignment and Reusability Analysis

## Executive Summary

The Form Dialog + PCF architecture provides **excellent alignment** with Office.js add-ins. Your core services (DocumentRecordService, EntityDocumentConfigService, SdapApiClient) are **fully reusable** in Office.js context with minimal adaptation. The separation of concerns in your current design naturally extends to Office add-ins.

## Architecture Alignment

### Current Architecture (Form Dialog + PCF)
```
Power Platform UI Layer (PCF)
           ↓
    Service Layer (TypeScript)
           ↓
    Platform APIs (Xrm.WebApi + SDAP API)
           ↓
    Data Layer (Dataverse + SharePoint Embedded)
```

### Office Add-in Architecture (Future)
```
Office UI Layer (Office.js Task Pane)
           ↓
    Service Layer (TypeScript) ← SAME SERVICES
           ↓
    Platform APIs (SDAP API + optional Xrm.WebApi)
           ↓
    Data Layer (Dataverse + SharePoint Embedded)
```

**Key Insight**: Your service layer is **platform-agnostic** by design. Office.js add-ins can consume the same services with different UI containers.

---

## Reusable Components (High Reusability)

### ✅ 100% Reusable Services

#### 1. **SdapApiClient.ts** - SharePoint Embedded Upload
```typescript
// NO CHANGES NEEDED - Already platform-agnostic
export class SdapApiClient {
    public async uploadFile(
        file: File, 
        containerId: string
    ): Promise<UploadResult> {
        // Uses standard Fetch API - works everywhere
        // No dependency on Xrm or Office.js
    }
}
```

**Use Cases in Office Add-ins:**
- **Outlook**: Upload email attachments as documents
- **Word**: Save current document to matter
- **Teams**: Upload shared files to matter containers

#### 2. **EntityDocumentConfigService.ts** - Entity Configuration
```typescript
// NO CHANGES NEEDED - Pure configuration logic
export class EntityDocumentConfigService {
    public static getConfig(entityName: string): EntityDocumentConfig {
        // No platform dependencies
    }
}
```

**Use Cases in Office Add-ins:**
- Matter/project selection dropdowns
- Validate user can upload to selected entity
- Display correct container relationships

#### 3. **FileUploadService.ts** - File Validation
```typescript
// NO CHANGES NEEDED - Pure validation logic
export class FileUploadService {
    public validateFiles(files: File[]): ValidationResult {
        // No platform dependencies
        // Works with File objects from any source
    }
}
```

**Use Cases in Office Add-ins:**
- Validate email attachments before upload
- Check Word document size/type
- Ensure Teams files meet requirements

#### 4. **LoggingService.ts** - Telemetry
```typescript
// MINOR ADAPTATION - Add Office.js diagnostics
export class LoggingService {
    public static initialize(context: any) {
        // Can accept ComponentFramework.Context OR Office context
        if (context.diagnostics) { // Office.js
            this._officeContext = context;
        } else if (context.client) { // PCF
            this._pcfContext = context;
        }
    }
}
```

**Use Cases in Office Add-ins:**
- Track add-in usage across Office apps
- Log errors to same Application Insights
- Unified telemetry across platforms

---

### ✅ 90% Reusable with Adapter Layer

#### 5. **DocumentRecordService.ts** - Record Creation
```typescript
// NEEDS ADAPTER - Xrm.WebApi not available in Office.js
export class DocumentRecordService {
    private apiClient: IDataverseApiClient; // Abstraction
    
    constructor(
        parentEntityName: string,
        parentRecordId: string,
        apiClient: IDataverseApiClient // Inject platform-specific impl
    ) {}
    
    public async createDocumentRecord(data: DocumentRecordData): Promise<DocumentRecordResult> {
        // Use injected API client instead of direct Xrm.WebApi
        return await this.apiClient.createRecord("sprk_document", recordData);
    }
}

// Platform-specific implementations
export class XrmDataverseClient implements IDataverseApiClient {
    async createRecord(entity: string, data: any) {
        return await Xrm.WebApi.createRecord(entity, data);
    }
}

export class SdapDataverseClient implements IDataverseApiClient {
    async createRecord(entity: string, data: any) {
        // Call SDAP BFF API endpoint
        return await fetch(`${SDAP_API}/dataverse/${entity}`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${await this.getToken()}` },
            body: JSON.stringify(data)
        });
    }
}
```

**Why This Matters:**
- Office.js add-ins **don't have Xrm.WebApi** access
- They call your **SDAP BFF API** instead
- Same business logic, different transport layer

---

## Office.js Add-in Scenarios

### Scenario 1: Outlook Add-in - Email to Matter

```typescript
// Outlook Task Pane
import { SdapApiClient } from '../shared/services/SdapApiClient';
import { DocumentRecordService } from '../shared/services/DocumentRecordService';
import { SdapDataverseClient } from '../shared/adapters/SdapDataverseClient';

async function saveEmailAsMatter() {
    const mailbox = Office.context.mailbox;
    
    // Get email details
    const subject = mailbox.item.subject;
    const attachments = mailbox.item.attachments;
    
    // User selects Matter (via SDAP API lookup)
    const selectedMatter = await showMatterPicker();
    
    // Reuse: SdapApiClient for file upload
    const sdapClient = new SdapApiClient();
    
    // Reuse: DocumentRecordService with SDAP adapter
    const dataverseClient = new SdapDataverseClient(await getOfficeToken());
    const docService = new DocumentRecordService(
        "sprk_matter",
        selectedMatter.id,
        dataverseClient // ← Different from PCF, same service
    );
    
    // Upload attachments
    for (const attachment of attachments) {
        const file = await getAttachmentAsFile(attachment);
        
        // ✅ Same upload logic as PCF
        const uploadResult = await sdapClient.uploadFile(file, selectedMatter.containerId);
        
        // ✅ Same record creation logic as PCF (different API transport)
        await docService.createDocumentRecord({
            fileName: file.name,
            fileSize: file.size,
            graphItemId: uploadResult.driveItemId,
            graphDriveId: selectedMatter.containerId,
            documentType: 4, // Correspondence
            description: `Email: ${subject}`
        });
    }
}
```

**Reused Components:**
- ✅ SdapApiClient (100% same)
- ✅ DocumentRecordService (90% same, injected adapter)
- ✅ EntityDocumentConfigService (100% same)
- ✅ FileUploadService (100% same)

### Scenario 2: Word Add-in - Save Document to Matter

```typescript
// Word Task Pane
async function saveDocumentToMatter() {
    const doc = Office.context.document;
    
    // Get document as blob
    const docBlob = await new Promise<Blob>((resolve) => {
        doc.getFileAsync(Office.FileType.Compressed, (result) => {
            const slices: any[] = [];
            const file = result.value;
            
            const getSlice = (sliceIndex: number) => {
                file.getSliceAsync(sliceIndex, (sliceResult) => {
                    slices.push(sliceResult.value.data);
                    if (sliceIndex < file.sliceCount - 1) {
                        getSlice(sliceIndex + 1);
                    } else {
                        file.closeAsync();
                        resolve(new Blob(slices));
                    }
                });
            };
            getSlice(0);
        });
    });
    
    // Convert to File object
    const file = new File([docBlob], "document.docx", { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });
    
    // ✅ Reuse validation service
    const validationService = new FileUploadService();
    const validation = validationService.validateFiles([file]);
    
    if (!validation.valid) {
        showError(validation.errors.join("; "));
        return;
    }
    
    // User selects Matter
    const selectedMatter = await showMatterPicker();
    
    // ✅ Reuse upload service
    const sdapClient = new SdapApiClient();
    const uploadResult = await sdapClient.uploadFile(file, selectedMatter.containerId);
    
    // ✅ Reuse document record service (with adapter)
    const dataverseClient = new SdapDataverseClient(await getOfficeToken());
    const docService = new DocumentRecordService("sprk_matter", selectedMatter.id, dataverseClient);
    
    await docService.createDocumentRecord({
        fileName: file.name,
        fileSize: file.size,
        graphItemId: uploadResult.driveItemId,
        graphDriveId: selectedMatter.containerId,
        documentType: 1, // Contract
        description: "Saved from Word"
    });
}
```

### Scenario 3: Teams App - Share File to Matter

```typescript
// Teams Personal Tab or Message Extension
import { app } from "@microsoft/teams-js";
import { SdapApiClient } from '../shared/services/SdapApiClient';

async function shareTeamsFileToMatter(teamsFileUrl: string) {
    // Initialize Teams SDK
    await app.initialize();
    const context = await app.getContext();
    
    // Download file from Teams
    const response = await fetch(teamsFileUrl, {
        headers: { 'Authorization': `Bearer ${context.user.token}` }
    });
    const blob = await response.blob();
    const file = new File([blob], extractFileName(teamsFileUrl));
    
    // ✅ Reuse SAME services as PCF and Office add-ins
    const sdapClient = new SdapApiClient();
    const uploadResult = await sdapClient.uploadFile(file, selectedMatter.containerId);
    
    const dataverseClient = new SdapDataverseClient(await getTeamsToken());
    const docService = new DocumentRecordService("sprk_matter", selectedMatter.id, dataverseClient);
    
    await docService.createDocumentRecord({
        fileName: file.name,
        fileSize: file.size,
        graphItemId: uploadResult.driveItemId,
        graphDriveId: selectedMatter.containerId
    });
}
```

---

## Recommended Shared Library Structure

```
/packages/
├── @spaarke/core-services/          ← NPM package (shared)
│   ├── src/
│   │   ├── services/
│   │   │   ├── SdapApiClient.ts           ✅ 100% reusable
│   │   │   ├── FileUploadService.ts       ✅ 100% reusable
│   │   │   ├── MultiFileUploadService.ts  ✅ 100% reusable
│   │   │   ├── LoggingService.ts          ✅ 90% reusable
│   │   │   └── EntityDocumentConfigService.ts ✅ 100% reusable
│   │   ├── interfaces/
│   │   │   ├── IDataverseApiClient.ts     ← Abstraction
│   │   │   ├── DocumentRecordData.ts
│   │   │   └── UploadResult.ts
│   │   └── models/
│   │       ├── EntityDocumentConfig.ts
│   │       └── ValidationResult.ts
│   ├── package.json
│   └── tsconfig.json
│
├── @spaarke/pcf-adapters/           ← PCF-specific
│   ├── src/
│   │   ├── XrmDataverseClient.ts          ← Uses Xrm.WebApi
│   │   └── PcfDocumentRecordService.ts    ← Wraps with Xrm adapter
│   └── package.json
│
├── @spaarke/office-adapters/        ← Office.js-specific
│   ├── src/
│   │   ├── SdapDataverseClient.ts         ← Uses BFF API
│   │   ├── OutlookAttachmentService.ts
│   │   ├── WordDocumentService.ts
│   │   └── TeamsFileService.ts
│   └── package.json
│
├── UniversalQuickCreatePCF/         ← PCF Control
│   ├── package.json
│   │   "dependencies": {
│   │       "@spaarke/core-services": "^1.0.0",
│   │       "@spaarke/pcf-adapters": "^1.0.0"
│   │   }
│   └── src/
│       └── index.ts
│
├── OutlookAddIn/                    ← Outlook Add-in
│   ├── package.json
│   │   "dependencies": {
│   │       "@spaarke/core-services": "^1.0.0",
│   │       "@spaarke/office-adapters": "^1.0.0",
│   │       "@microsoft/office-js": "^1.x"
│   │   }
│   └── src/
│       ├── taskpane/
│       │   └── EmailToMatter.tsx
│       └── manifest.xml
│
├── WordAddIn/                       ← Word Add-in
│   ├── package.json
│   │   "dependencies": {
│   │       "@spaarke/core-services": "^1.0.0",
│   │       "@spaarke/office-adapters": "^1.0.0"
│   │   }
│   └── src/
│       └── taskpane/
│           └── SaveToMatter.tsx
│
└── TeamsApp/                        ← Teams App
    ├── package.json
    │   "dependencies": {
    │       "@spaarke/core-services": "^1.0.0",
    │       "@spaarke/office-adapters": "^1.0.0",
    │       "@microsoft/teams-js": "^2.x"
    │   }
    └── src/
        └── tabs/
            └── ShareToMatter.tsx
```

---

## Interface Abstraction Pattern

### Core Abstraction (in @spaarke/core-services)

```typescript
// interfaces/IDataverseApiClient.ts
export interface IDataverseApiClient {
    createRecord(entityName: string, data: any): Promise<CreateRecordResult>;
    updateRecord(entityName: string, id: string, data: any): Promise<void>;
    deleteRecord(entityName: string, id: string): Promise<void>;
    retrieveRecord(entityName: string, id: string, columns?: string[]): Promise<any>;
}

export interface CreateRecordResult {
    id: string;
    entityType: string;
}
```

### PCF Implementation (in @spaarke/pcf-adapters)

```typescript
// XrmDataverseClient.ts
import { IDataverseApiClient, CreateRecordResult } from '@spaarke/core-services';

export class XrmDataverseClient implements IDataverseApiClient {
    public async createRecord(entityName: string, data: any): Promise<CreateRecordResult> {
        // ✅ Direct Xrm.WebApi access (available in Power Platform)
        const result = await Xrm.WebApi.createRecord(entityName, data);
        return {
            id: result.id,
            entityType: result.entityType
        };
    }

    public async updateRecord(entityName: string, id: string, data: any): Promise<void> {
        await Xrm.WebApi.updateRecord(entityName, id, data);
    }

    public async deleteRecord(entityName: string, id: string): Promise<void> {
        await Xrm.WebApi.deleteRecord(entityName, id);
    }

    public async retrieveRecord(entityName: string, id: string, columns?: string[]): Promise<any> {
        const selectQuery = columns ? `?$select=${columns.join(',')}` : '';
        return await Xrm.WebApi.retrieveRecord(entityName, id, selectQuery);
    }
}
```

### Office.js Implementation (in @spaarke/office-adapters)

```typescript
// SdapDataverseClient.ts
import { IDataverseApiClient, CreateRecordResult } from '@spaarke/core-services';

export class SdapDataverseClient implements IDataverseApiClient {
    private baseUrl: string;
    private tokenProvider: () => Promise<string>;

    constructor(tokenProvider: () => Promise<string>) {
        this.baseUrl = "https://api.spaarke.com/v1"; // SDAP BFF API
        this.tokenProvider = tokenProvider;
    }

    public async createRecord(entityName: string, data: any): Promise<CreateRecordResult> {
        // ✅ Call SDAP BFF API (available from Office.js add-ins)
        const token = await this.tokenProvider();
        
        const response = await fetch(`${this.baseUrl}/dataverse/${entityName}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });

        if (!response.ok) {
            throw new Error(`Failed to create record: ${response.statusText}`);
        }

        const result = await response.json();
        return {
            id: result.id,
            entityType: entityName
        };
    }

    public async updateRecord(entityName: string, id: string, data: any): Promise<void> {
        const token = await this.tokenProvider();
        await fetch(`${this.baseUrl}/dataverse/${entityName}/${id}`, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
    }

    // ... other methods
}
```

### Updated DocumentRecordService (in @spaarke/core-services)

```typescript
// services/DocumentRecordService.ts
import { EntityDocumentConfigService } from './EntityDocumentConfigService';
import { IDataverseApiClient } from '../interfaces/IDataverseApiClient';

export class DocumentRecordService {
    private parentEntityName: string;
    private parentRecordId: string;
    private apiClient: IDataverseApiClient; // ← Injected abstraction

    constructor(
        parentEntityName: string,
        parentRecordId: string,
        apiClient: IDataverseApiClient // ← Platform-agnostic
    ) {
        if (!EntityDocumentConfigService.isEntitySupported(parentEntityName)) {
            throw new Error(`Entity '${parentEntityName}' is not configured`);
        }

        this.parentEntityName = parentEntityName;
        this.parentRecordId = this.cleanGuid(parentRecordId);
        this.apiClient = apiClient;
    }

    public async createDocumentRecord(
        documentData: DocumentRecordData
    ): Promise<DocumentRecordResult> {
        try {
            const config = EntityDocumentConfigService.getConfig(this.parentEntityName);
            const lookupFieldName = config.documentLookupField;
            const entitySetName = config.entitySetName;

            const recordData: any = {
                "sprk_documentname": this.sanitizeFileName(documentData.fileName),
                "sprk_filename": documentData.fileName,
                "sprk_graphitemid": documentData.graphItemId,
                "sprk_graphdriveid": documentData.graphDriveId,
                "sprk_filesize": documentData.fileSize
            };

            if (documentData.documentType !== undefined) {
                recordData["sprk_documenttype"] = documentData.documentType;
            }

            if (documentData.description) {
                recordData["sprk_description"] = documentData.description;
            }

            recordData[`${lookupFieldName}@odata.bind`] = 
                `/${entitySetName}(${this.parentRecordId})`;

            // ✅ Uses injected API client (Xrm OR SDAP)
            const result = await this.apiClient.createRecord("sprk_document", recordData);

            return {
                documentId: result.id,
                fileName: documentData.fileName,
                success: true
            };

        } catch (error: any) {
            console.error(`Failed to create document record:`, error);
            return {
                documentId: "",
                fileName: documentData.fileName,
                success: false,
                error: error.message
            };
        }
    }

    // ... rest of service
}
```

---

## UI Layer Comparison

### PCF (Power Platform)
```typescript
// React component with Fluent UI v9
import { FluentProvider, Button, Input } from "@fluentui/react-components";
import { DocumentRecordService } from '@spaarke/core-services';
import { XrmDataverseClient } from '@spaarke/pcf-adapters';

const dataverseClient = new XrmDataverseClient();
const docService = new DocumentRecordService(
    parentEntityName,
    parentRecordId,
    dataverseClient
);
```

### Office.js (Outlook/Word/Excel)
```typescript
// React component with Fluent UI React v9 (same as PCF!)
import { FluentProvider, Button, Input } from "@fluentui/react-components";
import { DocumentRecordService } from '@spaarke/core-services';
import { SdapDataverseClient } from '@spaarke/office-adapters';

const tokenProvider = async () => {
    // Office SSO or OfficeRuntime.auth
    return await OfficeRuntime.auth.getAccessToken({ allowSignInPrompt: true });
};

const dataverseClient = new SdapDataverseClient(tokenProvider);
const docService = new DocumentRecordService(
    parentEntityName,
    parentRecordId,
    dataverseClient
);
```

**UI Components**: ✅ 90% reusable (same Fluent UI library, different layout containers)

---

## Authentication Differences

### PCF (Power Platform Context)
```typescript
// No explicit auth needed - runs in authenticated Power Platform session
const dataverseClient = new XrmDataverseClient();
// Xrm.WebApi uses current user's context automatically
```

### Office.js Add-ins
```typescript
// Use Office SSO to get token for SDAP API
const tokenProvider = async (): Promise<string> => {
    try {
        // Office SSO with fallback to dialog auth
        const token = await OfficeRuntime.auth.getAccessToken({
            allowSignInPrompt: true,
            allowConsentPrompt: true,
            forMSGraphAccess: false // For your SDAP API
        });
        return token;
    } catch (error) {
        // Fallback to dialog-based auth
        return await dialogAuth();
    }
};

const dataverseClient = new SdapDataverseClient(tokenProvider);
```

---

## SDAP BFF API Requirements for Office.js

Your SDAP BFF (ASP.NET Core Minimal API) needs these endpoints for Office.js support:

```csharp
// Add to your SDAP BFF API
app.MapPost("/api/v1/dataverse/{entityName}", async (
    string entityName,
    [FromBody] JsonDocument data,
    [FromServices] IOrganizationService dataverseService,
    HttpContext context) =>
{
    // Validate user token (from Office.js)
    var userId = context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    // Create record in Dataverse (server-side)
    var entity = new Entity(entityName);
    
    // Parse JSON to entity attributes
    foreach (var property in data.RootElement.EnumerateObject())
    {
        entity[property.Name] = ConvertValue(property.Value);
    }
    
    // Execute via Organization Service (server has full permissions)
    var recordId = await dataverseService.CreateAsync(entity);
    
    return Results.Created($"/api/v1/dataverse/{entityName}/{recordId}", new { id = recordId });
})
.RequireAuthorization("SpaarkeUser"); // Office token validated here

app.MapPatch("/api/v1/dataverse/{entityName}/{id}", async (
    string entityName,
    Guid id,
    [FromBody] JsonDocument data,
    [FromServices] IOrganizationService dataverseService) =>
{
    var entity = new Entity(entityName, id);
    
    foreach (var property in data.RootElement.EnumerateObject())
    {
        entity[property.Name] = ConvertValue(property.Value);
    }
    
    await dataverseService.UpdateAsync(entity);
    return Results.NoContent();
})
.RequireAuthorization("SpaarkeUser");
```

**Why This Works:**
- Office.js add-ins call your SDAP API (not Dataverse directly)
- Your API handles authentication (Office SSO token → Dataverse service principal)
- Same OData bind syntax works (your API translates to Organization Service)

---

## Deployment Strategy

### Phase 1: Current (PCF Only)
```
Power Platform Solution:
├── sprk_uploadcontext entity
├── UniversalQuickCreatePCF control
├── Command button web resource
└── Form definitions
```

### Phase 2: Add Office.js Support
```
NPM Packages:
├── @spaarke/core-services (extracted from PCF)
├── @spaarke/pcf-adapters (Xrm implementations)
└── @spaarke/office-adapters (SDAP API implementations)

SDAP BFF API:
├── /api/v1/dataverse/* endpoints (NEW)
└── Existing /api/v1/documents/* endpoints

Office Add-in Manifests:
├── outlook-addin-manifest.xml
├── word-addin-manifest.xml
└── teams-app-manifest.json

Power Platform Solution:
└── (unchanged - PCF continues working)
```

---

## Migration Path

### Step 1: Extract Core Services (Now)
```bash
# Create shared package
mkdir packages/@spaarke/core-services
cd packages/@spaarke/core-services

# Move services (keep copies in PCF temporarily)
cp ../../UniversalQuickCreatePCF/services/*.ts ./src/services/

# Add package.json
npm init -y
npm install --save-dev typescript @types/node
```

### Step 2: Add Abstraction Layer (Now)
```typescript
// Add IDataverseApiClient interface
// Update DocumentRecordService to accept injected client
// Create XrmDataverseClient wrapper for PCF
```

### Step 3: Update PCF to Use Shared Package (Now)
```json
// UniversalQuickCreatePCF/package.json
{
  "dependencies": {
    "@spaarke/core-services": "file:../../packages/@spaarke/core-services",
    "@spaarke/pcf-adapters": "file:../../packages/@spaarke/pcf-adapters"
  }
}
```

### Step 4: Build Office.js Add-ins (Future Phase)
```bash
# Use Yeoman generator
npm install -g yo generator-office

# Create Outlook add-in
yo office --projectType taskpane --name "Spaarke Outlook" --host outlook

# Install shared services
npm install @spaarke/core-services @spaarke/office-adapters
```

---

## Key Benefits of This Architecture

### 1. **Code Reuse** (60-90% depending on component)
- ✅ All business logic reused
- ✅ All validation reused
- ✅ All upload logic reused
- ⚠️ Only API transport layer differs

### 2. **Consistent Behavior**
- Same file validation rules across platforms
- Same document record structure
- Same error handling patterns
- Same telemetry/logging

### 3. **Maintainability**
- Fix bug once, applies everywhere
- Add entity support once, works in all contexts
- Update configuration once, reflected in all apps

### 4. **Testing**
```typescript
// Test once, works everywhere
describe('DocumentRecordService', () => {
    it('creates record with correct lookup', async () => {
        // Mock API client
        const mockClient = new MockDataverseClient();
        const service = new DocumentRecordService('sprk_matter', 'guid', mockClient);
        
        await service.createDocumentRecord(testData);
        
        // Assert called with correct OData bind syntax
        expect(mockClient.lastCall).toContain('@odata.bind');
    });
});
```

### 5. **Future-Proofing**
```typescript
// Easy to add new platforms
export class PowerAutomateDataverseClient implements IDataverseApiClient {
    // Power Automate cloud flows calling SDAP API
}

export class LogicAppDataverseClient implements IDataverseApiClient {
    // Logic Apps integration
}

export class CopilotDataverseClient implements IDataverseApiClient {
    // Copilot Studio actions calling SDAP API
}
```

---

## Summary: Alignment Score

| Component | Reusability | Office.js Alignment |
|-----------|-------------|---------------------|
| SdapApiClient | ✅ 100% | Perfect - Fetch API works everywhere |
| FileUploadService | ✅ 100% | Perfect - Pure validation logic |
| EntityDocumentConfigService | ✅ 100% | Perfect - Pure configuration |
| LoggingService | ✅ 90% | Minor adaptation for Office diagnostics |
| DocumentRecordService | ✅ 90% | Needs IDataverseApiClient abstraction |
| MultiFileUploadService | ✅ 100% | Perfect - Orchestration logic |
| React UI Components | ✅ 80% | Same Fluent UI, different containers |
| Form Dialog Architecture | ⚠️ N/A | Office uses Task Panes, not forms |

**Overall Reusability: 85-90%**

---

## Recommended Next Steps

1. **Now (During PCF Development)**:
   - Extract services to `@spaarke/core-services` package
   - Add `IDataverseApiClient` abstraction
   - Create `XrmDataverseClient` for PCF

2. **After PCF Deployment**:
   - Publish `@spaarke/core-services` to private NPM registry
   - Add SDAP BFF Dataverse endpoints
   - Create `@spaarke/office-adapters` package

3. **Office.js Phase**:
   - Build Outlook add-in (email attachments → documents)
   - Build Word add-in (save to matter)
   - Build Teams app (share files → documents)

---

**Bottom Line**: Your Form Dialog + PCF architecture is **excellently positioned** for Office.js add-ins. The service layer is highly reusable, and the separation of concerns allows easy platform adaptation. This is exactly the right design for multi-platform document management.