QUICK-CREATE-DIALOG-APPROACH.md

```markdown
# Pro-Code Form Dialog Solution for Universal Document Upload PCF

## Objective
Build a universal multi-document upload solution using Model-Driven Form Dialog (instead of Custom Page) to host a PCF control. This approach is fully pro-code compatible and avoids Canvas App/Custom Page creation issues.

## Architecture Overview

```
Subgrid Command → Xrm.Navigation.openForm() → Form Dialog → PCF Control → Xrm.WebApi
     ↓                    ↓                         ↓              ↓              ↓
  Parent          Launch with              Renders in      Upload UI +    Create multiple
  Context         parameters               dialog          validation     sprk_document
  (Matter,        (entity, ID,             (70% width,                    records
  Project,        container)               modal)
  etc.)
```

## Why Form Dialog Instead of Custom Page

**Key Benefits:**
- ✅ **Xrm.WebApi available** - unlimited record creation (no Quick Create limitation)
- ✅ **Pure XML definitions** - no Canvas App Studio required
- ✅ **Standard solution packaging** - entity + form + PCF + web resource
- ✅ **Better CI/CD** - simple XML export/import
- ✅ **Same PCF code** - identical Xrm.WebApi usage
- ✅ **Easier debugging** - standard form debugging tools

**What This Solves:**
- ❌ Custom Page creation issues in app builder
- ❌ Canvas App packaging complexity
- ❌ Quick Create single-record limitation
- ❌ context.webAPI 400 errors on second createRecord()

## Critical Constraints

### 1. Multiple Record Creation Requirement
```typescript
// ❌ FAILS - Quick Create + context.webAPI
await context.webAPI.createRecord("sprk_document", record1); // ✅ Works
await context.webAPI.createRecord("sprk_document", record2); // ❌ 400 Error

// ✅ WORKS - Form Dialog + Xrm.WebApi
for (const file of files) {
    await Xrm.WebApi.createRecord("sprk_document", recordData); // ✅ All succeed
}
```

### 2. Universal Entity Design
- Works with ANY parent entity (Matter, Project, Account, Contact, etc.)
- Dynamic lookup field mapping via configuration
- No hardcoded entity names

### 3. Technology Stack
- **PCF Framework**: TypeScript with React
- **UI Library**: Fluent UI v9 (`@fluentui/react-components`) - NOT v8
- **API Access**: `Xrm.WebApi.createRecord()` - NEVER `context.webAPI`
- **File Upload**: SDAP API to SharePoint Embedded
- **Record Creation**: Dataverse via Xrm.WebApi

## Implementation Components

### Component 1: Utility Entity for Dialog Context

**Purpose**: Lightweight entity to host the form dialog and pass parameters via hidden fields.

**File**: `Solutions/sprk_CoreControls/Entities/sprk_uploadcontext/Entity.xml`

```xml
<?xml version="1.0" encoding="utf-8"?>
<Entity>
  <Name LocalizedName="Upload Context" OriginalName="sprk_uploadcontext">sprk_uploadcontext</Name>
  <EntityInfo>
    <entity Name="sprk_uploadcontext">
      <LocalizedNames>
        <LocalizedName description="Upload Context" languagecode="1033" />
      </LocalizedNames>
      <LocalizedCollectionNames>
        <LocalizedCollectionName description="Upload Contexts" languagecode="1033" />
      </LocalizedCollectionNames>
      <Descriptions>
        <Description description="Utility entity for document upload dialog context" languagecode="1033" />
      </Descriptions>
      <attributes>
        <!-- Primary Name Field -->
        <attribute PhysicalName="sprk_name">
          <Type>nvarchar</Type>
          <Name>sprk_name</Name>
          <LogicalName>sprk_name</LogicalName>
          <RequiredLevel>ApplicationRequired</RequiredLevel>
          <DisplayMask>ValidForAdvancedFind|ValidForForm|ValidForGrid</DisplayMask>
          <ImeMode>Auto</ImeMode>
          <ValidForUpdateApi>1</ValidForUpdateApi>
          <ValidForReadApi>1</ValidForReadApi>
          <ValidForCreateApi>1</ValidForCreateApi>
          <IsCustomField>1</IsCustomField>
          <IsAuditEnabled>0</IsAuditEnabled>
          <MaxLength>100</MaxLength>
          <Format>Text</Format>
          <IsPrimaryName>1</IsPrimaryName>
          <LocalizedNames>
            <LocalizedName description="Name" languagecode="1033" />
          </LocalizedNames>
          <Descriptions>
            <Description description="Primary name field" languagecode="1033" />
          </Descriptions>
        </attribute>

        <!-- Parent Entity Name (hidden field for context passing) -->
        <attribute PhysicalName="sprk_parententityname">
          <Type>nvarchar</Type>
          <Name>sprk_parententityname</Name>
          <LogicalName>sprk_parententityname</LogicalName>
          <RequiredLevel>None</RequiredLevel>
          <DisplayMask>ValidForAdvancedFind</DisplayMask>
          <ImeMode>Auto</ImeMode>
          <ValidForUpdateApi>1</ValidForUpdateApi>
          <ValidForReadApi>1</ValidForReadApi>
          <ValidForCreateApi>1</ValidForCreateApi>
          <IsCustomField>1</IsCustomField>
          <IsAuditEnabled>0</IsAuditEnabled>
          <MaxLength>100</MaxLength>
          <Format>Text</Format>
          <LocalizedNames>
            <LocalizedName description="Parent Entity Name" languagecode="1033" />
          </LocalizedNames>
          <Descriptions>
            <Description description="Logical name of parent entity" languagecode="1033" />
          </Descriptions>
        </attribute>

        <!-- Parent Record ID (hidden field for context passing) -->
        <attribute PhysicalName="sprk_parentrecordid">
          <Type>nvarchar</Type>
          <Name>sprk_parentrecordid</Name>
          <LogicalName>sprk_parentrecordid</LogicalName>
          <RequiredLevel>None</RequiredLevel>
          <DisplayMask>ValidForAdvancedFind</DisplayMask>
          <ImeMode>Auto</ImeMode>
          <ValidForUpdateApi>1</ValidForUpdateApi>
          <ValidForReadApi>1</ValidForReadApi>
          <ValidForCreateApi>1</ValidForCreateApi>
          <IsCustomField>1</IsCustomField>
          <IsAuditEnabled>0</IsAuditEnabled>
          <MaxLength>100</MaxLength>
          <Format>Text</Format>
          <LocalizedNames>
            <LocalizedName description="Parent Record ID" languagecode="1033" />
          </LocalizedNames>
          <Descriptions>
            <Description description="GUID of parent record" languagecode="1033" />
          </Descriptions>
        </attribute>

        <!-- Container ID (hidden field for SPE container) -->
        <attribute PhysicalName="sprk_containerid">
          <Type>nvarchar</Type>
          <Name>sprk_containerid</Name>
          <LogicalName>sprk_containerid</LogicalName>
          <RequiredLevel>None</RequiredLevel>
          <DisplayMask>ValidForAdvancedFind</DisplayMask>
          <ImeMode>Auto</ImeMode>
          <ValidForUpdateApi>1</ValidForUpdateApi>
          <ValidForReadApi>1</ValidForReadApi>
          <ValidForCreateApi>1</ValidForCreateApi>
          <IsCustomField>1</IsCustomField>
          <IsAuditEnabled>0</IsAuditEnabled>
          <MaxLength>100</MaxLength>
          <Format>Text</Format>
          <LocalizedNames>
            <LocalizedName description="Container ID" languagecode="1033" />
          </LocalizedNames>
          <Descriptions>
            <Description description="SharePoint Embedded container ID" languagecode="1033" />
          </Descriptions>
        </attribute>

        <!-- Parent Display Name (hidden field for UI display) -->
        <attribute PhysicalName="sprk_parentdisplayname">
          <Type>nvarchar</Type>
          <Name>sprk_parentdisplayname</Name>
          <LogicalName>sprk_parentdisplayname</LogicalName>
          <RequiredLevel>None</RequiredLevel>
          <DisplayMask>ValidForAdvancedFind</DisplayMask>
          <ImeMode>Auto</ImeMode>
          <ValidForUpdateApi>1</ValidForUpdateApi>
          <ValidForReadApi>1</ValidForReadApi>
          <ValidForCreateApi>1</ValidForCreateApi>
          <IsCustomField>1</IsCustomField>
          <IsAuditEnabled>0</IsAuditEnabled>
          <MaxLength>200</MaxLength>
          <Format>Text</Format>
          <LocalizedNames>
            <LocalizedName description="Parent Display Name" languagecode="1033" />
          </LocalizedNames>
          <Descriptions>
            <Description description="Display name of parent record" languagecode="1033" />
          </Descriptions>
        </attribute>
      </attributes>
    </entity>
  </EntityInfo>
  <FormXml>
    <forms type="main">
      <!-- Form definition in next component -->
    </forms>
  </FormXml>
  <RibbonDiffXml />
  <CustomControlDefaultConfigs />
  <EntityMaps />
</Entity>
```

### Component 2: Dialog Form with PCF Control

**Purpose**: Form that hosts the PCF control and passes hidden field values as parameters.

**File**: `Solutions/sprk_CoreControls/Entities/sprk_uploadcontext/Forms/UploadDialog.xml`

```xml
<?xml version="1.0" encoding="utf-8"?>
<form>
  <tabs>
    <tab name="tab_upload" id="{GUID-TAB-001}" verticallayout="true" showlabel="false">
      <labels>
        <label description="Upload Documents" languagecode="1033" />
      </labels>
      <columns>
        <column width="100%">
          <sections>
            <!-- Section 1: PCF Control (full width) -->
            <section name="section_pcf" showlabel="false" showbar="false" id="{GUID-SECTION-001}" cellspacing="0">
              <labels>
                <label description="Upload Interface" languagecode="1033" />
              </labels>
              <rows>
                <row>
                  <cell id="{GUID-CELL-001}" showlabel="false" colspan="1">
                    <!-- PCF Control Binding -->
                    <control id="sprk_universaluploadpcf" 
                             classid="{YOUR-PCF-CONTROL-GUID}"
                             datafieldname="sprk_name"
                             disabled="false">
                      <parameters>
                        <!-- Bind PCF input properties to entity fields -->
                        <DataFieldName>sprk_name</DataFieldName>
                        <parentEntityName>sprk_parententityname</parentEntityName>
                        <parentRecordId>sprk_parentrecordid</parentRecordId>
                        <containerId>sprk_containerid</containerId>
                        <parentDisplayName>sprk_parentdisplayname</parentDisplayName>
                      </parameters>
                    </control>
                  </cell>
                </row>
              </rows>
            </section>

            <!-- Section 2: Hidden Fields (not visible, for data binding only) -->
            <section name="section_hidden" showlabel="false" showbar="false" visible="false" id="{GUID-SECTION-002}">
              <labels>
                <label description="Context Fields" languagecode="1033" />
              </labels>
              <rows>
                <row>
                  <cell id="{GUID-CELL-002}">
                    <control id="sprk_parententityname" datafieldname="sprk_parententityname" disabled="true" />
                  </cell>
                </row>
                <row>
                  <cell id="{GUID-CELL-003}">
                    <control id="sprk_parentrecordid" datafieldname="sprk_parentrecordid" disabled="true" />
                  </cell>
                </row>
                <row>
                  <cell id="{GUID-CELL-004}">
                    <control id="sprk_containerid" datafieldname="sprk_containerid" disabled="true" />
                  </cell>
                </row>
                <row>
                  <cell id="{GUID-CELL-005}">
                    <control id="sprk_parentdisplayname" datafieldname="sprk_parentdisplayname" disabled="true" />
                  </cell>
                </row>
              </rows>
            </section>
          </sections>
        </column>
      </columns>
    </tab>
  </tabs>
  <Navigation>
    <NavBarByRelationshipItem />
  </Navigation>
  <formLibraries>
    <!-- Optional: Add form libraries if needed for PCF initialization -->
  </formLibraries>
  <events>
    <!-- Optional: Form onLoad event for initialization -->
  </events>
  <controlDescriptions>
    <controlDescription forControl="sprk_universaluploadpcf">
      <customControl formFactor="0" name="Spaarke.UniversalQuickCreatePCF">
        <parameters />
      </customControl>
      <customControl formFactor="1" name="Spaarke.UniversalQuickCreatePCF">
        <parameters />
      </customControl>
      <customControl formFactor="2" name="Spaarke.UniversalQuickCreatePCF">
        <parameters />
      </customControl>
    </controlDescription>
  </controlDescriptions>
</form>
```

### Component 3: Entity Configuration Service

**Purpose**: Map parent entity names to their document lookup fields and container ID fields.

**File**: `UniversalQuickCreatePCF/services/EntityDocumentConfigService.ts`

```typescript
/**
 * Entity Document Configuration
 * Maps parent entities to their document relationship and container fields
 */
export interface EntityDocumentConfig {
    /** Logical name of the parent entity (e.g., "sprk_matter") */
    entityLogicalName: string;
    
    /** Entity set name for Web API (e.g., "sprk_matters") */
    entitySetName: string;
    
    /** Lookup field name on sprk_document (e.g., "sprk_matter") */
    documentLookupField: string;
    
    /** Field name on parent entity containing SPE container ID */
    containerIdField: string;
    
    /** Primary name field(s) for display */
    displayNameFields: string[];
}

/**
 * Configuration registry for all entities that can have documents
 * ADD NEW ENTITIES HERE to extend universal support
 */
export const ENTITY_DOCUMENT_CONFIGS: EntityDocumentConfig[] = [
    {
        entityLogicalName: "sprk_matter",
        entitySetName: "sprk_matters",
        documentLookupField: "sprk_matter",
        containerIdField: "sprk_containerid",
        displayNameFields: ["sprk_name", "sprk_matternumber"]
    },
    {
        entityLogicalName: "sprk_project",
        entitySetName: "sprk_projects",
        documentLookupField: "sprk_project",
        containerIdField: "sprk_projectcontainerid",
        displayNameFields: ["sprk_projectname"]
    },
    {
        entityLogicalName: "account",
        entitySetName: "accounts",
        documentLookupField: "sprk_account",
        containerIdField: "sprk_specontainerid",
        displayNameFields: ["name"]
    },
    {
        entityLogicalName: "contact",
        entitySetName: "contacts",
        documentLookupField: "sprk_contact",
        containerIdField: "sprk_specontainerid",
        displayNameFields: ["fullname"]
    },
    {
        entityLogicalName: "sprk_invoice",
        entitySetName: "sprk_invoices",
        documentLookupField: "sprk_invoice",
        containerIdField: "sprk_invoicecontainerid",
        displayNameFields: ["sprk_invoicenumber"]
    }
    // Add more entities as needed
];

/**
 * Service for entity document configuration lookups
 */
export class EntityDocumentConfigService {
    private static configMap: Map<string, EntityDocumentConfig> = new Map(
        ENTITY_DOCUMENT_CONFIGS.map(config => [config.entityLogicalName, config])
    );

    /**
     * Get configuration for an entity
     * @throws Error if entity not configured
     */
    public static getConfig(entityLogicalName: string): EntityDocumentConfig {
        const config = this.configMap.get(entityLogicalName.toLowerCase());
        if (!config) {
            throw new Error(
                `Entity '${entityLogicalName}' is not configured for document upload. ` +
                `Add configuration to ENTITY_DOCUMENT_CONFIGS in EntityDocumentConfigService.ts`
            );
        }
        return config;
    }

    /**
     * Check if entity is configured for documents
     */
    public static isEntitySupported(entityLogicalName: string): boolean {
        return this.configMap.has(entityLogicalName.toLowerCase());
    }

    /**
     * Get all supported entity names
     */
    public static getSupportedEntities(): string[] {
        return Array.from(this.configMap.keys());
    }

    /**
     * Get lookup field name for document entity
     */
    public static getLookupFieldName(entityLogicalName: string): string {
        return this.getConfig(entityLogicalName).documentLookupField;
    }

    /**
     * Get entity set name for Web API
     */
    public static getEntitySetName(entityLogicalName: string): string {
        return this.getConfig(entityLogicalName).entitySetName;
    }

    /**
     * Get container ID field name
     */
    public static getContainerIdField(entityLogicalName: string): string {
        return this.getConfig(entityLogicalName).containerIdField;
    }
}
```

### Component 4: Document Record Creation Service

**Purpose**: Create sprk_document records using Xrm.WebApi with dynamic lookup binding.

**File**: `UniversalQuickCreatePCF/services/DocumentRecordService.ts`

```typescript
import { EntityDocumentConfigService } from './EntityDocumentConfigService';

/**
 * Document record data for creation
 */
export interface DocumentRecordData {
    fileName: string;
    fileSize: number;
    graphItemId: string;
    graphDriveId: string;
    documentType?: number; // Option set value
    description?: string;
}

/**
 * Result of document record creation
 */
export interface DocumentRecordResult {
    documentId: string;
    fileName: string;
    success: boolean;
    error?: string;
}

/**
 * Service for creating sprk_document records via Xrm.WebApi
 * Uses dynamic lookup binding based on parent entity configuration
 */
export class DocumentRecordService {
    private parentEntityName: string;
    private parentRecordId: string;

    constructor(parentEntityName: string, parentRecordId: string) {
        // Validate parent entity is supported
        if (!EntityDocumentConfigService.isEntitySupported(parentEntityName)) {
            throw new Error(
                `Parent entity '${parentEntityName}' is not configured. ` +
                `Supported entities: ${EntityDocumentConfigService.getSupportedEntities().join(', ')}`
            );
        }

        this.parentEntityName = parentEntityName;
        this.parentRecordId = this.cleanGuid(parentRecordId);
    }

    /**
     * Create a single document record
     * Uses Xrm.WebApi.createRecord() - works in Form Dialog context
     */
    public async createDocumentRecord(
        documentData: DocumentRecordData
    ): Promise<DocumentRecordResult> {
        try {
            // Get entity configuration for dynamic lookup binding
            const config = EntityDocumentConfigService.getConfig(this.parentEntityName);
            const lookupFieldName = config.documentLookupField;
            const entitySetName = config.entitySetName;

            // Build record data with dynamic lookup
            const recordData: any = {
                "sprk_documentname": this.sanitizeFileName(documentData.fileName),
                "sprk_filename": documentData.fileName,
                "sprk_graphitemid": documentData.graphItemId,
                "sprk_graphdriveid": documentData.graphDriveId,
                "sprk_filesize": documentData.fileSize
            };

            // Add optional fields
            if (documentData.documentType !== undefined) {
                recordData["sprk_documenttype"] = documentData.documentType;
            }

            if (documentData.description) {
                recordData["sprk_description"] = documentData.description;
            }

            // ✅ CRITICAL: Dynamic lookup binding using OData bind syntax
            // Format: "lookupfield@odata.bind": "/entitysetname(guid)"
            recordData[`${lookupFieldName}@odata.bind`] = 
                `/${entitySetName}(${this.parentRecordId})`;

            // ✅ Create record using Xrm.WebApi (unlimited records in Form Dialog)
            const result = await Xrm.WebApi.createRecord("sprk_document", recordData);

            return {
                documentId: result.id,
                fileName: documentData.fileName,
                success: true
            };

        } catch (error: any) {
            console.error(`Failed to create document record for ${documentData.fileName}:`, error);
            
            return {
                documentId: "",
                fileName: documentData.fileName,
                success: false,
                error: error.message || "Unknown error creating document record"
            };
        }
    }

    /**
     * Create multiple document records (batch)
     * Each file upload to SPE followed by Dataverse record creation
     */
    public async createDocumentRecords(
        documentsData: DocumentRecordData[]
    ): Promise<DocumentRecordResult[]> {
        const results: DocumentRecordResult[] = [];

        // Process sequentially to avoid race conditions
        for (const docData of documentsData) {
            const result = await this.createDocumentRecord(docData);
            results.push(result);
        }

        return results;
    }

    /**
     * Sanitize file name for document name field
     * Remove extension, trim, limit length
     */
    private sanitizeFileName(fileName: string): string {
        // Remove file extension
        const nameWithoutExt = fileName.replace(/\.[^/.]+$/, "");
        
        // Trim and limit to 100 characters (field max length)
        return nameWithoutExt.trim().substring(0, 100);
    }

    /**
     * Clean GUID format (remove braces if present)
     */
    private cleanGuid(guid: string): string {
        return guid.replace(/[{}]/g, "");
    }

    /**
     * Validate parent entity and record ID before operations
     */
    public static validateContext(
        parentEntityName: string, 
        parentRecordId: string
    ): { valid: boolean; error?: string } {
        if (!parentEntityName || parentEntityName.trim() === "") {
            return { valid: false, error: "Parent entity name is required" };
        }

        if (!EntityDocumentConfigService.isEntitySupported(parentEntityName)) {
            return { 
                valid: false, 
                error: `Entity '${parentEntityName}' is not configured for documents` 
            };
        }

        if (!parentRecordId || parentRecordId.trim() === "") {
            return { valid: false, error: "Parent record ID is required" };
        }

        // Basic GUID validation
        const guidPattern = /^[{]?[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}[}]?$/;
        const cleanGuid = parentRecordId.replace(/[{}]/g, "");
        if (!guidPattern.test(cleanGuid)) {
            return { valid: false, error: "Invalid parent record ID format" };
        }

        return { valid: true };
    }
}
```

### Component 5: Command Button Web Resource

**Purpose**: Launch form dialog from subgrid command button with parent context.

**File**: `WebResources/sprk_subgrid_commands.js`

```javascript
/**
 * Spaarke Subgrid Commands
 * Universal document upload command button for any entity with documents subgrid
 */

/**
 * Launch document upload dialog from subgrid
 * @param {object} selectedControl - Primary control (subgrid)
 */
function addMultipleDocuments(selectedControl) {
    try {
        // Get parent form context
        const formContext = selectedControl.getFormContext();
        
        if (!formContext) {
            showError("Cannot access form context");
            return;
        }

        // Get parent entity information
        const parentEntityName = formContext.data.entity.getEntityName();
        const parentRecordId = formContext.data.entity.getId().replace(/[{}]/g, '');
        
        // Get container ID based on entity configuration
        const containerId = getContainerIdForEntity(formContext, parentEntityName);
        
        if (!containerId) {
            showError(`No SharePoint Embedded container found for this ${parentEntityName}. Please ensure a container is assigned.`);
            return;
        }

        // Get display name for UI
        const parentDisplayName = getDisplayNameForEntity(formContext, parentEntityName);

        // Open form dialog with parameters
        // Note: We pass data via formParameters which populate the hidden fields
        const formId = "YOUR-UPLOAD-FORM-GUID"; // TODO: Replace with actual form GUID from solution

        Xrm.Navigation.openForm({
            entityName: "sprk_uploadcontext",
            useQuickCreateForm: false,
            formId: formId,
            
            // These parameters will populate the hidden fields on the form
            // The PCF will read them from its bound input properties
            formParameters: {
                "sprk_name": `Upload to ${parentDisplayName}`,
                "sprk_parententityname": parentEntityName,
                "sprk_parentrecordid": parentRecordId,
                "sprk_containerid": containerId,
                "sprk_parentdisplayname": parentDisplayName
            }
        }, {
            // Dialog options
            target: 2, // Modal dialog
            position: 1, // Center
            width: { value: 70, unit: "%" },
            height: { value: 80, unit: "%" }
        }).then(
            function success(result) {
                // Dialog closed successfully - refresh subgrid
                console.log("Upload dialog closed, refreshing subgrid");
                selectedControl.refresh();
            },
            function error(error) {
                console.error("Failed to open upload dialog:", error);
                showError("Failed to open upload dialog: " + error.message);
            }
        );

    } catch (error) {
        console.error("Error in addMultipleDocuments:", error);
        showError("An error occurred: " + error.message);
    }
}

/**
 * Get container ID field value for entity
 * Maps entity to its SPE container field name
 * @param {object} formContext - Form context
 * @param {string} entityName - Entity logical name
 * @returns {string|null} Container ID or null
 */
function getContainerIdForEntity(formContext, entityName) {
    // Entity to container field mapping
    const containerFieldMap = {
        "sprk_matter": "sprk_containerid",
        "sprk_project": "sprk_projectcontainerid",
        "account": "sprk_specontainerid",
        "contact": "sprk_specontainerid",
        "sprk_invoice": "sprk_invoicecontainerid"
        // Add more entities as needed
    };

    const fieldName = containerFieldMap[entityName.toLowerCase()];
    
    if (!fieldName) {
        console.warn(`No container field mapping found for entity: ${entityName}`);
        return null;
    }

    const attribute = formContext.getAttribute(fieldName);
    
    if (!attribute) {
        console.warn(`Container field '${fieldName}' not found on form for ${entityName}`);
        return null;
    }

    const value = attribute.getValue();
    return value || null;
}

/**
 * Get display name for parent record
 * @param {object} formContext - Form context
 * @param {string} entityName - Entity logical name
 * @returns {string} Display name or default
 */
function getDisplayNameForEntity(formContext, entityName) {
    // Entity to display name field mapping (priority order)
    const displayFieldMap = {
        "sprk_matter": ["sprk_name", "sprk_matternumber"],
        "sprk_project": ["sprk_projectname"],
        "account": ["name"],
        "contact": ["fullname"],
        "sprk_invoice": ["sprk_invoicenumber"]
        // Add more entities as needed
    };

    const fieldNames = displayFieldMap[entityName.toLowerCase()];
    
    if (!fieldNames || fieldNames.length === 0) {
        return `Record`;
    }

    // Try each field in priority order
    for (const fieldName of fieldNames) {
        const attribute = formContext.getAttribute(fieldName);
        if (attribute) {
            const value = attribute.getValue();
            if (value) {
                return value;
            }
        }
    }

    return `Record`;
}

/**
 * Show error notification
 * @param {string} message - Error message
 */
function showError(message) {
    Xrm.Navigation.openAlertDialog({
        text: message,
        title: "Upload Error"
    });
}

/**
 * Enable rule for command button
 * Only show when parent record has a container ID
 * @param {object} selectedControl - Primary control
 * @returns {boolean} True if button should be enabled
 */
function canAddDocuments(selectedControl) {
    try {
        const formContext = selectedControl.getFormContext();
        if (!formContext) {
            return false;
        }

        const parentEntityName = formContext.data.entity.getEntityName();
        const containerId = getContainerIdForEntity(formContext, parentEntityName);

        return containerId !== null && containerId.trim() !== "";
    } catch (error) {
        console.error("Error in canAddDocuments:", error);
        return false;
    }
}
```

### Component 6: PCF Component (Updated for Form Dialog)

**Purpose**: Main PCF control that reads form parameters and orchestrates upload.

**File**: `UniversalQuickCreatePCF/index.ts`

```typescript
import { IInputs, IOutputs } from "./generated/ManifestTypes";
import { createRoot, Root } from "react-dom/client";
import * as React from "react";
import { UniversalUploadApp } from "./components/UniversalUploadApp";
import { DocumentRecordService } from "./services/DocumentRecordService";
import { LoggingService } from "./services/LoggingService";

export class UniversalQuickCreatePCF implements ComponentFramework.StandardControl<IInputs, IOutputs> {
    private _container: HTMLDivElement;
    private _context: ComponentFramework.Context<IInputs>;
    private _notifyOutputChanged: () => void;
    private _reactRoot: Root;
    private _parentEntityName: string;
    private _parentRecordId: string;
    private _containerId: string;
    private _parentDisplayName: string;

    /**
     * Initialize the control
     * Called once when control is loaded
     */
    public init(
        context: ComponentFramework.Context<IInputs>,
        notifyOutputChanged: () => void,
        state: ComponentFramework.Dictionary,
        container: HTMLDivElement
    ): void {
        this._container = container;
        this._context = context;
        this._notifyOutputChanged = notifyOutputChanged;

        // ✅ Read parameters from form field bindings
        this._parentEntityName = context.parameters.parentEntityName.raw || "";
        this._parentRecordId = context.parameters.parentRecordId.raw || "";
        this._containerId = context.parameters.containerId.raw || "";
        this._parentDisplayName = context.parameters.parentDisplayName?.raw || "Record";

        // Initialize logging
        LoggingService.initialize(context);
        LoggingService.logInfo("PCF Initialized", {
            parentEntity: this._parentEntityName,
            parentRecordId: this._parentRecordId,
            hasContainerId: !!this._containerId
        });

        // Validate context
        const validation = DocumentRecordService.validateContext(
            this._parentEntityName,
            this._parentRecordId
        );

        if (!validation.valid) {
            LoggingService.logError("Invalid context", new Error(validation.error));
            this.renderError(validation.error || "Invalid context");
            return;
        }

        // Validate Xrm is available (required for Xrm.WebApi)
        if (typeof Xrm === "undefined") {
            LoggingService.logError("Xrm not available", new Error("Form Dialog context required"));
            this.renderError("This control must run in a Form Dialog context where Xrm.WebApi is available");
            return;
        }

        // Render React app
        this.renderApp();
    }

    /**
     * Update view when parameters change
     */
    public updateView(context: ComponentFramework.Context<IInputs>): void {
        this._context = context;

        // Check if parameters changed
        const parentEntityChanged = this._parentEntityName !== context.parameters.parentEntityName.raw;
        const parentRecordChanged = this._parentRecordId !== context.parameters.parentRecordId.raw;
        const containerChanged = this._containerId !== context.parameters.containerId.raw;

        if (parentEntityChanged || parentRecordChanged || containerChanged) {
            this._parentEntityName = context.parameters.parentEntityName.raw || "";
            this._parentRecordId = context.parameters.parentRecordId.raw || "";
            this._containerId = context.parameters.containerId.raw || "";
            this._parentDisplayName = context.parameters.parentDisplayName?.raw || "Record";

            LoggingService.logInfo("PCF Parameters Updated", {
                parentEntity: this._parentEntityName,
                parentRecordId: this._parentRecordId
            });

            // Re-render with new context
            this.renderApp();
        }
    }

    /**
     * Get outputs (if needed for two-way binding)
     */
    public getOutputs(): IOutputs {
        return {};
    }

    /**
     * Cleanup when control is destroyed
     */
    public destroy(): void {
        if (this._reactRoot) {
            this._reactRoot.unmount();
        }
        LoggingService.logInfo("PCF Destroyed");
    }

    /**
     * Render React application
     */
    private renderApp(): void {
        // Create root if not exists
        if (!this._reactRoot) {
            this._reactRoot = createRoot(this._container);
        }

        // Render React app with context
        this._reactRoot.render(
            React.createElement(UniversalUploadApp, {
                parentEntityName: this._parentEntityName,
                parentRecordId: this._parentRecordId,
                containerId: this._containerId,
                parentDisplayName: this._parentDisplayName,
                onComplete: this.handleUploadComplete.bind(this),
                onCancel: this.handleUploadCancel.bind(this)
            })
        );
    }

    /**
     * Render error state
     */
    private renderError(message: string): void {
        if (!this._reactRoot) {
            this._reactRoot = createRoot(this._container);
        }

        this._reactRoot.render(
            React.createElement("div", {
                style: {
                    padding: "20px",
                    color: "#d13438",
                    backgroundColor: "#fde7e9",
                    border: "1px solid #d13438",
                    borderRadius: "4px"
                }
            }, [
                React.createElement("strong", { key: "title" }, "Configuration Error"),
                React.createElement("p", { key: "message" }, message)
            ])
        );
    }

    /**
     * Handle upload completion
     */
    private handleUploadComplete(uploadedCount: number): void {
        LoggingService.logInfo("Upload completed", { uploadedCount });

        // Show success notification
        if (typeof Xrm !== "undefined" && Xrm.Navigation) {
            Xrm.Navigation.openAlertDialog({
                text: `Successfully uploaded ${uploadedCount} document(s) to ${this._parentDisplayName}`,
                title: "Upload Complete"
            }).then(() => {
                // Close the dialog form
                this.closeDialog();
            });
        } else {
            // Fallback if Xrm not available
            this.closeDialog();
        }
    }

    /**
     * Handle upload cancellation
     */
    private handleUploadCancel(): void {
        LoggingService.logInfo("Upload cancelled by user");
        this.closeDialog();
    }

    /**
     * Close the form dialog
     */
    private closeDialog(): void {
        if (typeof Xrm !== "undefined" && Xrm.Navigation) {
            // Close current form (dialog)
            Xrm.Navigation.closeDialog();
        }
    }
}
```

### Component 7: React App Component (Fluent UI v9)

**Purpose**: Main UI component with file selection, validation, progress, and upload orchestration.

**File**: `UniversalQuickCreatePCF/components/UniversalUploadApp.tsx`

```typescript
import * as React from "react";
import { useState, useCallback } from "react";
import {
    FluentProvider,
    webLightTheme,
    Button,
    Field,
    Input,
    ProgressBar,
    MessageBar,
    MessageBarBody,
    MessageBarTitle,
    Dropdown,
    Option,
    makeStyles,
    tokens
} from "@fluentui/react-components";
import { DocumentRecordService, DocumentRecordData } from "../services/DocumentRecordService";
import { FileUploadService } from "../services/FileUploadService";
import { MultiFileUploadService } from "../services/MultiFileUploadService";
import { SdapApiClient } from "../services/SdapApiClient";
import { LoggingService } from "../services/LoggingService";

// Fluent UI v9 styles
const useStyles = makeStyles({
    container: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalL,
        padding: tokens.spacingVerticalXL,
        maxWidth: "800px",
        margin: "0 auto"
    },
    header: {
        fontSize: tokens.fontSizeBase500,
        fontWeight: tokens.fontWeightSemibold,
        marginBottom: tokens.spacingVerticalS
    },
    fileList: {
        listStyle: "none",
        padding: 0,
        margin: 0,
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalS
    },
    fileItem: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        padding: tokens.spacingVerticalS,
        backgroundColor: tokens.colorNeutralBackground2,
        borderRadius: tokens.borderRadiusMedium
    },
    footer: {
        display: "flex",
        justifyContent: "flex-end",
        gap: tokens.spacingHorizontalM,
        marginTop: tokens.spacingVerticalL
    }
});

interface UniversalUploadAppProps {
    parentEntityName: string;
    parentRecordId: string;
    containerId: string;
    parentDisplayName: string;
    onComplete: (uploadedCount: number) => void;
    onCancel: () => void;
}

export const UniversalUploadApp: React.FC<UniversalUploadAppProps> = ({
    parentEntityName,
    parentRecordId,
    containerId,
    parentDisplayName,
    onComplete,
    onCancel
}) => {
    const styles = useStyles();

    // State
    const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
    const [documentType, setDocumentType] = useState<number | undefined>(undefined);
    const [description, setDescription] = useState<string>("");
    const [isUploading, setIsUploading] = useState(false);
    const [uploadProgress, setUploadProgress] = useState(0);
    const [errorMessage, setErrorMessage] = useState<string | null>(null);
    const [successMessage, setSuccessMessage] = useState<string | null>(null);

    // Services
    const fileUploadService = new FileUploadService();
    const sdapApiClient = new SdapApiClient();
    const documentRecordService = new DocumentRecordService(parentEntityName, parentRecordId);

    /**
     * Handle file selection
     */
    const handleFileSelect = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
        setErrorMessage(null);
        setSuccessMessage(null);

        const files = Array.from(event.target.files || []);

        // Validate files
        const validation = fileUploadService.validateFiles(files);

        if (!validation.valid) {
            setErrorMessage(validation.errors.join("; "));
            return;
        }

        setSelectedFiles(files);
    }, []);

    /**
     * Remove file from selection
     */
    const handleRemoveFile = useCallback((fileToRemove: File) => {
        setSelectedFiles(prev => prev.filter(f => f !== fileToRemove));
    }, []);

    /**
     * Handle upload and save
     */
    const handleUpload = useCallback(async () => {
        if (selectedFiles.length === 0) {
            setErrorMessage("Please select at least one file");
            return;
        }

        setIsUploading(true);
        setErrorMessage(null);
        setSuccessMessage(null);
        setUploadProgress(0);

        try {
            // Phase 1: Upload files to SharePoint Embedded
            const uploadService = new MultiFileUploadService(sdapApiClient);
            
            const uploadResults = await uploadService.uploadFiles(
                selectedFiles,
                containerId,
                (progress) => {
                    // Update progress (0-50% for upload phase)
                    setUploadProgress(progress * 0.5);
                }
            );

            // Check for upload failures
            const failedUploads = uploadResults.filter(r => !r.success);
            if (failedUploads.length > 0) {
                const errorMsg = `Failed to upload ${failedUploads.length} file(s): ${
                    failedUploads.map(r => r.fileName).join(", ")
                }`;
                LoggingService.logError("Upload phase failed", new Error(errorMsg));
                setErrorMessage(errorMsg);
                setIsUploading(false);
                return;
            }

            LoggingService.logInfo("Upload phase completed", {
                uploadedCount: uploadResults.length
            });

            // Phase 2: Create Dataverse records
            setUploadProgress(50); // Upload complete, starting record creation

            const documentsData: DocumentRecordData[] = uploadResults.map(result => ({
                fileName: result.fileName,
                fileSize: result.file.size,
                graphItemId: result.driveItemId || "",
                graphDriveId: containerId, // Using container ID as drive ID
                documentType: documentType,
                description: description || undefined
            }));

            // Create records using Xrm.WebApi
            const recordResults = await documentRecordService.createDocumentRecords(documentsData);

            // Update progress during record creation
            const recordProgressIncrement = 50 / recordResults.length;
            recordResults.forEach((_, index) => {
                setUploadProgress(50 + (index + 1) * recordProgressIncrement);
            });

            // Check for record creation failures
            const failedRecords = recordResults.filter(r => !r.success);
            if (failedRecords.length > 0) {
                const errorMsg = `Failed to create ${failedRecords.length} document record(s): ${
                    failedRecords.map(r => r.fileName).join(", ")
                }`;
                LoggingService.logError("Record creation failed", new Error(errorMsg));
                setErrorMessage(errorMsg);
                setIsUploading(false);
                return;
            }

            // Success!
            const successCount = recordResults.filter(r => r.success).length;
            LoggingService.logInfo("Upload and record creation completed", {
                successCount,
                parentEntity: parentEntityName
            });

            setSuccessMessage(`Successfully uploaded and saved ${successCount} document(s)`);
            setUploadProgress(100);

            // Call completion callback after brief delay
            setTimeout(() => {
                onComplete(successCount);
            }, 1500);

        } catch (error: any) {
            LoggingService.logError("Upload process failed", error);
            setErrorMessage(error.message || "An unexpected error occurred");
            setIsUploading(false);
            setUploadProgress(0);
        }
    }, [selectedFiles, documentType, description, containerId, parentEntityName, onComplete]);

    /**
     * Format file size for display
     */
    const formatFileSize = (bytes: number): string => {
        if (bytes === 0) return "0 Bytes";
        const k = 1024;
        const sizes = ["Bytes", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + " " + sizes[i];
    };

    return (
        <FluentProvider theme={webLightTheme}>
            <div className={styles.container}>
                {/* Header */}
                <div>
                    <h2 className={styles.header}>
                        Upload Documents to {parentDisplayName}
                    </h2>
                    <p>Select up to 10 files (max 10MB each) to upload</p>
                </div>

                {/* Error Message */}
                {errorMessage && (
                    <MessageBar intent="error">
                        <MessageBarBody>
                            <MessageBarTitle>Error</MessageBarTitle>
                            {errorMessage}
                        </MessageBarBody>
                    </MessageBar>
                )}

                {/* Success Message */}
                {successMessage && (
                    <MessageBar intent="success">
                        <MessageBarBody>
                            <MessageBarTitle>Success</MessageBarTitle>
                            {successMessage}
                        </MessageBarBody>
                    </MessageBar>
                )}

                {/* File Selection */}
                <Field label="Select Files">
                    <Input
                        type="file"
                        multiple
                        accept="*/*"
                        onChange={handleFileSelect}
                        disabled={isUploading}
                    />
                </Field>

                {/* Selected Files List */}
                {selectedFiles.length > 0 && (
                    <div>
                        <div className={styles.header}>
                            Selected Files ({selectedFiles.length})
                        </div>
                        <ul className={styles.fileList}>
                            {selectedFiles.map((file, index) => (
                                <li key={index} className={styles.fileItem}>
                                    <div>
                                        <div>{file.name}</div>
                                        <div style={{ fontSize: tokens.fontSizeBase200, color: tokens.colorNeutralForeground3 }}>
                                            {formatFileSize(file.size)}
                                        </div>
                                    </div>
                                    <Button
                                        appearance="subtle"
                                        onClick={() => handleRemoveFile(file)}
                                        disabled={isUploading}
                                    >
                                        Remove
                                    </Button>
                                </li>
                            ))}
                        </ul>
                    </div>
                )}

                {/* Document Type (Optional) */}
                <Field label="Document Type (optional - applies to all files)">
                    <Dropdown
                        placeholder="Select document type"
                        value={documentType?.toString()}
                        onOptionSelect={(_, data) => setDocumentType(data.optionValue ? parseInt(data.optionValue) : undefined)}
                        disabled={isUploading}
                    >
                        <Option value="1">Contract</Option>
                        <Option value="2">Invoice</Option>
                        <Option value="3">Report</Option>
                        <Option value="4">Correspondence</Option>
                        <Option value="5">Other</Option>
                    </Dropdown>
                </Field>

                {/* Description (Optional) */}
                <Field label="Description (optional - applies to all files)">
                    <Input
                        value={description}
                        onChange={(_, data) => setDescription(data.value)}
                        disabled={isUploading}
                        placeholder="Enter description for all documents"
                    />
                </Field>

                {/* Progress Bar */}
                {isUploading && (
                    <div>
                        <ProgressBar value={uploadProgress / 100} />
                        <div style={{ textAlign: "center", marginTop: tokens.spacingVerticalS }}>
                            {uploadProgress < 50 
                                ? `Uploading files... ${Math.round(uploadProgress)}%`
                                : `Creating document records... ${Math.round(uploadProgress)}%`
                            }
                        </div>
                    </div>
                )}

                {/* Footer Buttons */}
                <div className={styles.footer}>
                    <Button
                        appearance="secondary"
                        onClick={onCancel}
                        disabled={isUploading}
                    >
                        Cancel
                    </Button>
                    <Button
                        appearance="primary"
                        onClick={handleUpload}
                        disabled={selectedFiles.length === 0 || isUploading}
                    >
                        {isUploading ? "Uploading..." : "Upload & Save"}
                    </Button>
                </div>
            </div>
        </FluentProvider>
    );
};
```

## Critical Implementation Rules

### 1. Record Creation Pattern
```typescript
// ✅ ALWAYS USE - Unlimited records in Form Dialog
await Xrm.WebApi.createRecord("sprk_document", {
    "sprk_documentname": fileName,
    [`${lookupFieldName}@odata.bind`]: `/${entitySetName}(${parentRecordId})`
});

// ❌ NEVER USE - Fails after first record
await context.webAPI.createRecord("sprk_document", {...});
```

### 2. OData Lookup Binding
```typescript
// ✅ CORRECT - Clean OData bind syntax
{
    "sprk_documentname": "Contract.pdf",
    "sprk_matter@odata.bind": "/sprk_matters(guid-here)"
}

// ❌ WRONG - Base field with null
{
    "sprk_documentname": "Contract.pdf",
    "sprk_matter": null,
    "sprk_matter@odata.bind": "/sprk_matters(guid-here)"
}
```

### 3. Fluent UI v9 Components
```typescript
// ✅ CORRECT - v9 imports
import { Button, Input, Field } from "@fluentui/react-components";

// ❌ WRONG - v8 imports (don't exist in v9)
import { PrimaryButton, TextField, Stack } from "@fluentui/react";
```

### 4. Universal Entity Handling
```typescript
// ✅ CORRECT - Configuration-driven
const config = EntityDocumentConfigService.getConfig(parentEntityName);
const lookupField = config.documentLookupField;

// ❌ WRONG - Hardcoded entity checks
if (parentEntityName === "sprk_matter") {
    lookupField = "sprk_matter";
} else if (parentEntityName === "sprk_project") {
    // ...
}
```

## Testing Strategy

### Unit Tests
```typescript
describe('DocumentRecordService', () => {
    it('should create record with dynamic lookup', async () => {
        const service = new DocumentRecordService('sprk_matter', 'test-guid');
        const result = await service.createDocumentRecord({
            fileName: 'test.pdf',
            fileSize: 1024,
            graphItemId: 'item-id',
            graphDriveId: 'drive-id'
        });
        expect(result.success).toBe(true);
    });
});
```

### Integration Tests
1. **Test in DEV environment** with sprk_uploadcontext entity created
2. **Validate form dialog** opens from subgrid command
3. **Verify PCF loads** with correct parameters
4. **Upload files** and confirm sprk_document records created
5. **Check lookup relationships** are correct for different parent entities

## Deployment Checklist

- [ ] Create `sprk_uploadcontext` entity in DEV
- [ ] Create upload form with PCF control binding
- [ ] Build and package PCF control
- [ ] Upload command button web resource (`sprk_subgrid_commands.js`)
- [ ] Configure subgrid command on all parent entities (Matter, Project, etc.)
- [ ] Update `ENTITY_DOCUMENT_CONFIGS` with all required entities
- [ ] Test with each parent entity type
- [ ] Package as managed solution for UAT/PROD

```

## Key Differences from Custom Page Approach

| Aspect | Custom Page | Form Dialog |
|--------|-------------|-------------|
| Container | Custom Page (Canvas App) | Model-Driven Form |
| Xrm Access | ✅ Available | ✅ Available |
| Parameter Passing | navigateTo data object | formParameters + field binding |
| Creation Tool | Canvas Studio / PAC CLI | XML definitions |
| Deployment | Canvas App package | Standard entity + form |
| Pro-Code Friendly | ⚠️ Requires msapp packaging | ✅ Pure XML |
| CI/CD | ⚠️ Canvas unpack/pack | ✅ Simple solution import |

## Next Steps for Claude Code

1. **Generate utility entity XML** with correct schema
2. **Generate form XML** with PCF control binding and hidden fields
3. **Update PCF manifest** to match form field names
4. **Implement DocumentRecordService** with Xrm.WebApi
5. **Update command button** to use openForm() instead of navigateTo()
6. **Build React component** with Fluent UI v9
7. **Test end-to-end** flow in DEV environment

## Success Criteria

- ✅ Form dialog opens from subgrid command button
- ✅ PCF receives parent context via form parameters
- ✅ Multiple files can be uploaded (no 400 errors)
- ✅ sprk_document records created with correct lookups
- ✅ Works with ANY parent entity (Matter, Project, Account, etc.)
- ✅ No Custom Page or Canvas App required
- ✅ Pure XML solution packaging

---

**This approach is fully pro-code compatible and solves the Custom Page creation issues while maintaining all required functionality.**
```