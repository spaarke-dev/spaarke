{
  "id": "b1c2d3e4-f5a6-4b5c-9d8e-004004004004",
  "name": "SYS-SKL-BUILDER-004-NodeTypeGuide",
  "displayName": "Node Type Guide",
  "description": "Guidance on when and how to use each playbook node type. Provides selection criteria, configuration patterns, and best practices for each node type.",
  "scopeType": "Skill",
  "ownerType": 1,
  "isImmutable": true,
  "promptFragment": "## Node Type Selection Guide\n\nWhen building playbooks, select the appropriate node type based on the required functionality:\n\n### AI Analysis Node (aiAnalysis)\n\n**Use When:**\n- Extracting information from document text\n- Generating summaries or analysis\n- Classifying content or detecting patterns\n- Any task requiring LLM reasoning\n\n**Configuration:**\n- action: System prompt defining the analysis task\n- skills[]: Domain expertise to include\n- knowledge[]: RAG sources for context\n- outputVariable: Where to store results\n- outputSchema: Expected structure of output\n\n**Best Practices:**\n- Keep each node focused on one task\n- Use clear output variable names\n- Include skills for domain-specific analysis\n- Add knowledge sources for reference data\n\n---\n\n### Condition Node (condition)\n\n**Use When:**\n- Branching workflow based on values\n- Routing documents by type or classification\n- Implementing approval/rejection logic\n- Skipping steps based on prior analysis\n\n**Configuration:**\n- expression: JavaScript-like condition (e.g., `riskLevel === 'HIGH'`)\n- trueLabel: Branch label when condition is true\n- falseLabel: Branch label when condition is false\n\n**Best Practices:**\n- Use descriptive branch labels\n- Keep conditions simple and readable\n- Handle null/undefined values gracefully\n- Consider multi-way branching with nested conditions\n\n---\n\n### Assemble Node (assemble)\n\n**Use When:**\n- Combining outputs from multiple prior nodes\n- Creating composite analysis results\n- Merging parallel processing branches\n- Preparing data for final delivery\n\n**Configuration:**\n- inputVariables[]: Variables to combine\n- outputVariable: Combined result variable\n- format: How to combine (object, array, template)\n- template: Optional template for structured output\n\n**Best Practices:**\n- Place after all contributing nodes complete\n- Define clear output structure\n- Handle missing inputs gracefully\n- Use templates for consistent formatting\n\n---\n\n### Deliver Node (deliver)\n\n**Use When:**\n- Outputting final results\n- Saving analysis to Dataverse fields\n- Sending results to external systems\n- Generating reports or documents\n\n**Configuration:**\n- deliveryType: 'dataverse' | 'api' | 'blob' | 'email'\n- destination: Target location/endpoint\n- format: Output format (JSON, HTML, PDF)\n- fieldMappings: Map variables to destination fields\n\n**Best Practices:**\n- Always end playbook with deliver node\n- Map outputs to appropriate Dataverse fields\n- Include metadata (timestamp, playbook version)\n- Handle delivery failures gracefully\n\n---\n\n### Loop Node (loop)\n\n**Use When:**\n- Processing collections of items\n- Analyzing multiple documents\n- Iterating over extracted entities\n- Parallel or sequential item processing\n\n**Configuration:**\n- collectionVariable: Array to iterate over\n- itemVariable: Current item variable name\n- maxIterations: Safety limit\n- parallel: Process items in parallel (if supported)\n\n**Best Practices:**\n- Set reasonable iteration limits\n- Handle empty collections\n- Consider memory for large collections\n- Use parallel when items are independent\n\n---\n\n### Transform Node (transform)\n\n**Use When:**\n- Converting data formats\n- Filtering or mapping arrays\n- Calculating derived values\n- Restructuring output for delivery\n\n**Configuration:**\n- transformType: 'map' | 'filter' | 'reduce' | 'custom'\n- inputVariable: Source data\n- outputVariable: Transformed result\n- expression: Transformation logic\n\n**Best Practices:**\n- Keep transformations simple\n- Use for data cleanup before delivery\n- Document complex transformations\n- Test with edge cases\n\n---\n\n### Human Review Node (humanReview)\n\n**Use When:**\n- High-risk decisions need approval\n- AI confidence is low\n- Regulatory requirements mandate review\n- Exception handling workflows\n\n**Configuration:**\n- reviewPrompt: Instructions for reviewer\n- timeoutHours: Auto-escalation timeout\n- escalationPath: Who to escalate to\n- requiredActions: Approve/Reject/Modify options\n\n**Best Practices:**\n- Provide clear context for reviewers\n- Set reasonable timeout windows\n- Define escalation paths\n- Track review decisions for audit\n\n---\n\n### External API Node (externalApi)\n\n**Use When:**\n- Calling external services\n- Integrating with third-party systems\n- Fetching additional data\n- Triggering external workflows\n\n**Configuration:**\n- endpoint: API URL\n- method: HTTP method\n- headers: Request headers\n- body: Request body template\n- responseMapping: Extract fields from response\n\n**Best Practices:**\n- Implement retry logic\n- Handle timeouts gracefully\n- Secure credentials properly\n- Log API interactions for debugging",
  "metadata": {
    "tags": ["builder", "skill", "node-types", "guide", "reference"],
    "applicableDocTypes": ["ALL"],
    "expertiseArea": "playbook-design",
    "version": "1.0.0",
    "category": "builder-reference"
  }
}
