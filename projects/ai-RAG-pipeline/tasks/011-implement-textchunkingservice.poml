<?xml version="1.0" encoding="UTF-8"?>
<task id="011" project="ai-RAG-pipeline">
  <metadata>
    <title>Implement TextChunkingService</title>
    <phase>1: Core Pipeline</phase>
    <status>not-started</status>
    <estimated-hours>3</estimated-hours>
    <dependencies>010</dependencies>
    <blocks>013, 018</blocks>
    <tags>bff-api, ai, services</tags>
    <rigor-hint>FULL</rigor-hint>
    <rigor-reason>Task implements core service with algorithmic logic</rigor-reason>
  </metadata>

  <prompt>
    Implement TextChunkingService that extracts and consolidates the chunking logic from
    SummaryHandler.cs. The implementation should handle configurable chunk size, overlap,
    and sentence boundary preservation. This becomes the single source of truth for chunking.
  </prompt>

  <role>
    SPAARKE platform developer. Expert in text processing algorithms and service implementation.
    Follow ADR-013 for AI architecture patterns.
  </role>

  <goal>
    TextChunkingService implemented with extracted chunking logic.
    Service handles sentence boundaries, configurable chunk size/overlap.
  </goal>

  <context>
    <background>
      The chunking logic in SummaryHandler.cs (lines 479-517) splits text into chunks while
      trying to preserve sentence boundaries. This logic needs to be extracted into a reusable
      service that all tool handlers and the new FileIndexingService can use.
    </background>
    <relevant-files>
      <file>src/server/api/Sprk.Bff.Api/Services/Ai/ITextChunkingService.cs</file>
      <file>src/server/api/Sprk.Bff.Api/Services/Ai/TextChunkingService.cs</file>
      <file>src/server/api/Sprk.Bff.Api/Services/Ai/Tools/SummaryHandler.cs</file>
    </relevant-files>
  </context>

  <constraints>
    <constraint source="ADR-013">Implement within BFF API services</constraint>
    <constraint source="project">Extract logic from SummaryHandler.cs lines 479-517</constraint>
    <constraint source="project">Defaults: 4000 char chunks, 200 char overlap, preserve sentences</constraint>
  </constraints>

  <knowledge>
    <files>
      <file>.claude/adr/ADR-013-ai-architecture.md</file>
      <file>.claude/constraints/ai.md</file>
      <file>projects/ai-RAG-pipeline/spec.md</file>
    </files>
    <patterns>
      <pattern name="Chunking Algorithm" location="src/server/api/Sprk.Bff.Api/Services/Ai/Tools/SummaryHandler.cs:479-517">
        Source chunking logic to extract and refine
      </pattern>
    </patterns>
  </knowledge>

  <steps>
    <step order="1">Read SummaryHandler.cs ChunkText method carefully (lines 479-517)</step>
    <step order="2">Create TextChunkingService.cs in Services/Ai/</step>
    <step order="3">Implement ITextChunkingService interface</step>
    <step order="4">Extract chunking logic: character-based splitting with sentence boundary detection</step>
    <step order="5">Add overlap handling: include overlap characters from previous chunk</step>
    <step order="6">Add sentence boundary detection: find last sentence end (., !, ?) before chunk boundary</step>
    <step order="7">Handle edge cases: empty text, text shorter than chunk size, no sentence boundaries</step>
    <step order="8">Add logging for chunk count and sizes (no content per ADR-015)</step>
    <step order="9">Run dotnet build to verify compilation</step>
    <step order="10">Update TASK-INDEX.md: change task 011 status to âœ… completed</step>
  </steps>

  <tools>
    <tool name="dotnet">Build and test .NET projects</tool>
    <tool name="terminal">Run shell commands</tool>
  </tools>

  <outputs>
    <output type="code">src/server/api/Sprk.Bff.Api/Services/Ai/TextChunkingService.cs</output>
  </outputs>

  <acceptance-criteria>
    <criterion testable="true">TextChunkingService.cs exists and implements ITextChunkingService</criterion>
    <criterion testable="true">ChunkTextAsync splits text into chunks of configured size</criterion>
    <criterion testable="true">Overlap is applied between adjacent chunks</criterion>
    <criterion testable="true">Sentence boundaries are preserved when possible</criterion>
    <criterion testable="true">Empty text returns empty list</criterion>
    <criterion testable="true">dotnet build succeeds without errors</criterion>
  </acceptance-criteria>

  <notes>
    The algorithm should be:
    1. Start at position 0
    2. Find position at chunkSize
    3. If preserving sentences, backtrack to last sentence end (., !, ?)
    4. Create chunk from start to adjusted position
    5. Move start to (adjusted position - overlap)
    6. Repeat until end of text
  </notes>

  <execution>
    <skill>.claude/skills/task-execute/SKILL.md</skill>
    <protocol>
      Before starting this task, load all files listed in knowledge/files.
      Follow the task-execute skill for mandatory pre-execution checklist.
    </protocol>
  </execution>
</task>
