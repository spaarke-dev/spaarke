import * as React from "react";
import {
  Dialog,
  DialogSurface,
  DialogTitle,
  DialogBody,
  DialogActions,
  Button,
  Text,
  Spinner,
  Divider,
  Badge,
  makeStyles,
  tokens,
} from "@fluentui/react-components";
import { SparkleRegular, DismissRegular } from "@fluentui/react-icons";
import { IQuickSummary } from "../../types";
import {
  generateDeterministicNarrative,
  IBriefingMetrics,
  INarrativeSection,
} from "./briefingNarrative";

// ---------------------------------------------------------------------------
// BFF response type
// ---------------------------------------------------------------------------

/**
 * Matches the shape of BriefingResponse from the BFF.
 * Mirrors the C# record: BriefingResponse in
 * Sprk.Bff.Api/Api/Workspace/Models/BriefingResponse.cs
 */
interface IBriefingResponse {
  activeMatters: number;
  totalSpend: number;
  totalBudget: number;
  utilizationPercent: number;
  mattersAtRisk: number;
  overdueEvents: number;
  topPriorityMatter?: {
    matterId: string;
    name: string;
    deadline?: string | null;
    reason: string;
  } | null;
  /** Pre-built narrative from the BFF (template or AI-generated). */
  narrative: string;
  /** True when the BFF narrative was AI-generated by PlaybookService. */
  isAiEnhanced: boolean;
  generatedAt: string;
}

// ---------------------------------------------------------------------------
// Props
// ---------------------------------------------------------------------------

export interface IBriefingDialogProps {
  /** Controls dialog visibility. */
  open: boolean;
  /** Called when the user closes the dialog. */
  onClose: () => void;
  /**
   * Portfolio quick summary data already available from the parent.
   * Used to build the deterministic narrative without an additional BFF call
   * when the BFF briefing endpoint fails or times out.
   */
  summary?: IQuickSummary;
  /**
   * Base URL for the BFF API (e.g. "https://spe-api-dev-67e2xz.azurewebsites.net").
   * When omitted the dialog renders the deterministic narrative only.
   */
  bffBaseUrl?: string;
  /**
   * Bearer token for BFF authentication.
   * When omitted the BFF call is skipped and deterministic mode is used.
   */
  accessToken?: string;
}

// ---------------------------------------------------------------------------
// Styles
// ---------------------------------------------------------------------------

const useStyles = makeStyles({
  surface: {
    // Constrain width for readability
    width: "520px",
    maxWidth: "90vw",
  },
  titleRow: {
    display: "flex",
    alignItems: "center",
    gap: tokens.spacingHorizontalS,
  },
  titleText: {
    color: tokens.colorNeutralForeground1,
  },
  aiBadge: {
    display: "flex",
    alignItems: "center",
    gap: tokens.spacingHorizontalXS,
    // Align badge with title text baseline
    marginTop: "2px",
  },
  aiBadgeText: {
    color: tokens.colorBrandForeground1,
  },
  body: {
    display: "flex",
    flexDirection: "column",
    gap: tokens.spacingVerticalM,
    paddingTop: tokens.spacingVerticalS,
    paddingBottom: tokens.spacingVerticalS,
  },
  headline: {
    color: tokens.colorNeutralForeground1,
  },
  loadingContainer: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    minHeight: "160px",
  },
  errorText: {
    color: tokens.colorPaletteRedForeground1,
  },
  section: {
    display: "flex",
    flexDirection: "column",
    gap: tokens.spacingVerticalXS,
  },
  sectionLabel: {
    color: tokens.colorNeutralForeground3,
  },
  sectionText: {
    color: tokens.colorNeutralForeground1,
  },
  /** Applied to paragraph text when the section describes a risk/overdue condition. */
  sectionTextDanger: {
    color: tokens.colorPaletteRedForeground1,
  },
  divider: {
    marginTop: tokens.spacingVerticalXS,
    marginBottom: tokens.spacingVerticalXS,
  },
  generatedAtText: {
    color: tokens.colorNeutralForeground4,
    textAlign: "right",
    marginTop: tokens.spacingVerticalXS,
  },
});

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Build IBriefingMetrics from IQuickSummary for the deterministic path. */
function metricsFromSummary(summary: IQuickSummary): IBriefingMetrics {
  return {
    activeMatters: summary.activeCount,
    mattersAtRisk: summary.atRiskCount,
    overdueEvents: summary.overdueCount,
    topPriorityMatterName: summary.topPriorityMatter,
    // IQuickSummary does not carry utilization — default to 0
    utilizationPercent: 0,
  };
}

/** Build IBriefingMetrics from a BFF BriefingResponse for the deterministic path. */
function metricsFromBriefingResponse(resp: IBriefingResponse): IBriefingMetrics {
  return {
    activeMatters: resp.activeMatters,
    mattersAtRisk: resp.mattersAtRisk,
    overdueEvents: resp.overdueEvents,
    topPriorityMatterName: resp.topPriorityMatter?.name,
    topPriorityDeadline: resp.topPriorityMatter?.deadline ?? null,
    utilizationPercent: resp.utilizationPercent,
  };
}

/** Format a UTC ISO string into a short locale date-time: "Feb 18, 2026, 3:42 PM". */
function formatGeneratedAt(iso: string): string {
  try {
    const d = new Date(iso);
    if (isNaN(d.getTime())) return iso;
    return d.toLocaleString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "2-digit",
    });
  } catch {
    return iso;
  }
}

// ---------------------------------------------------------------------------
// Internal content component
// ---------------------------------------------------------------------------

interface IBriefingContentProps {
  sections: INarrativeSection[];
  headline: string;
  isAiEnhanced: boolean;
  /** Displayed at the bottom of the body ("Generated Feb 18, 2026, 3:42 PM"). */
  generatedAt?: string;
}

const BriefingContent: React.FC<IBriefingContentProps> = ({
  sections,
  headline,
  isAiEnhanced,
  generatedAt,
}) => {
  const styles = useStyles();

  return (
    <div className={styles.body}>
      {/* Headline summary */}
      <Text size={300} weight="semibold" className={styles.headline}>
        {headline}
      </Text>

      <Divider className={styles.divider} />

      {/* Narrative sections */}
      {sections.map((section, index) => (
        <React.Fragment key={section.key}>
          <div className={styles.section}>
            <Text size={100} weight="semibold" className={styles.sectionLabel}>
              {section.label.toUpperCase()}
            </Text>
            <Text
              size={200}
              className={
                section.isDanger
                  ? styles.sectionTextDanger
                  : styles.sectionText
              }
            >
              {section.text}
            </Text>
          </div>
          {index < sections.length - 1 && (
            <Divider className={styles.divider} />
          )}
        </React.Fragment>
      ))}

      {/* Timestamp footer */}
      {(generatedAt || isAiEnhanced) && (
        <Text size={100} className={styles.generatedAtText}>
          {isAiEnhanced ? "AI-enhanced" : "Template-based"}
          {generatedAt ? ` · Generated ${formatGeneratedAt(generatedAt)}` : ""}
        </Text>
      )}
    </div>
  );
};

BriefingContent.displayName = "BriefingContent";

// ---------------------------------------------------------------------------
// Main component
// ---------------------------------------------------------------------------

/**
 * BriefingDialog — expanded portfolio briefing dialog opened from QuickSummaryCard.
 *
 * Rendering modes:
 *   1. **Deterministic** (always available): Builds narrative from the summary prop
 *      using generateDeterministicNarrative(). No network call required.
 *   2. **AI-Enhanced** (when bffBaseUrl + accessToken provided): Fetches
 *      GET /api/workspace/briefing from the BFF with a 3-second timeout.
 *      If the BFF returns IsAiEnhanced=true, shows an "AI-enhanced" badge.
 *      Falls back to deterministic mode on any error or timeout.
 *
 * Design constraints:
 * - Fluent v9 Dialog, DialogSurface, DialogTitle, DialogBody, DialogActions
 * - makeStyles + semantic tokens — ZERO hardcoded colors
 * - At-risk and overdue sections use colorPaletteRedForeground1
 * - Supports light, dark, and high-contrast via Fluent token system
 * - BFF call NEVER made from client when bffBaseUrl/accessToken are absent
 */
export const BriefingDialog: React.FC<IBriefingDialogProps> = ({
  open,
  onClose,
  summary,
  bffBaseUrl,
  accessToken,
}) => {
  const styles = useStyles();

  // --- State ---
  const [isLoading, setIsLoading] = React.useState(false);
  const [briefingResp, setBriefingResp] = React.useState<IBriefingResponse | null>(null);
  const [fetchError, setFetchError] = React.useState<string | null>(null);

  // --- Fetch BFF briefing when dialog opens ---
  React.useEffect(() => {
    if (!open) {
      // Reset on close so next open is a fresh fetch
      setBriefingResp(null);
      setFetchError(null);
      return;
    }

    // Skip BFF call if not configured
    if (!bffBaseUrl || !accessToken) {
      return;
    }

    let cancelled = false;
    const controller = new AbortController();

    // Enforce 3-second timeout per task spec
    const timeoutId = window.setTimeout(() => {
      controller.abort();
    }, 3000);

    const fetchBriefing = async (): Promise<void> => {
      setIsLoading(true);
      setFetchError(null);

      try {
        const response = await fetch(`${bffBaseUrl}/api/workspace/briefing`, {
          method: "GET",
          headers: {
            Authorization: `Bearer ${accessToken}`,
            Accept: "application/json",
          },
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error(
            `Briefing endpoint returned ${response.status} ${response.statusText}`
          );
        }

        const data: IBriefingResponse = await response.json();

        if (!cancelled) {
          setBriefingResp(data);
        }
      } catch (err: unknown) {
        if (!cancelled) {
          // AbortError = timeout; log but silently fall back to deterministic
          const isAbort =
            err instanceof DOMException && err.name === "AbortError";
          if (!isAbort) {
            setFetchError("Could not load AI narrative — showing standard briefing.");
          }
          // briefingResp remains null → deterministic fallback renders
        }
      } finally {
        clearTimeout(timeoutId);
        if (!cancelled) {
          setIsLoading(false);
        }
      }
    };

    fetchBriefing();

    return (): void => {
      cancelled = true;
      clearTimeout(timeoutId);
      controller.abort();
    };
  }, [open, bffBaseUrl, accessToken]);

  // --- Derive narrative ---
  const { narrative, isAiEnhanced, generatedAt } = React.useMemo(() => {
    // AI-enhanced path: BFF returned a narrative
    if (briefingResp) {
      if (briefingResp.isAiEnhanced) {
        // Use AI narrative as single section
        const aiSections: INarrativeSection[] = [
          {
            key: "ai-narrative",
            label: "Portfolio Briefing",
            text: briefingResp.narrative,
            isDanger: briefingResp.mattersAtRisk > 0 || briefingResp.overdueEvents > 0,
          },
        ];
        const aiHeadline =
          `Portfolio overview: ${briefingResp.activeMatters} active ` +
          `${briefingResp.activeMatters === 1 ? "matter" : "matters"}, ` +
          `${briefingResp.mattersAtRisk} at risk.`;
        return {
          narrative: { headline: aiHeadline, sections: aiSections },
          isAiEnhanced: true,
          generatedAt: briefingResp.generatedAt,
        };
      }

      // BFF returned metrics + template narrative — build full deterministic sections
      const metrics = metricsFromBriefingResponse(briefingResp);
      return {
        narrative: generateDeterministicNarrative(metrics),
        isAiEnhanced: false,
        generatedAt: briefingResp.generatedAt,
      };
    }

    // Deterministic fallback: use IQuickSummary prop
    if (summary) {
      const metrics = metricsFromSummary(summary);
      return {
        narrative: generateDeterministicNarrative(metrics),
        isAiEnhanced: false,
        generatedAt: undefined,
      };
    }

    // No data at all: minimal placeholder
    return {
      narrative: {
        headline: "Portfolio briefing",
        sections: [
          {
            key: "no-data",
            label: "Status",
            text: "No portfolio data is available to display at this time.",
            isDanger: false,
          },
        ],
      },
      isAiEnhanced: false,
      generatedAt: undefined,
    };
  }, [briefingResp, summary]);

  // --- Render ---
  return (
    <Dialog open={open} onOpenChange={(_, data) => !data.open && onClose()}>
      <DialogSurface className={styles.surface}>
        <DialogTitle
          action={
            <Button
              appearance="subtle"
              aria-label="Close Portfolio Briefing dialog"
              size="small"
              icon={<DismissRegular aria-hidden="true" />}
              onClick={onClose}
            />
          }
        >
          <div className={styles.titleRow}>
            <Text size={500} weight="semibold" className={styles.titleText}>
              Portfolio Briefing
            </Text>
            {isAiEnhanced && (
              <div className={styles.aiBadge} aria-label="AI-enhanced briefing">
                <SparkleRegular fontSize={14} color={tokens.colorBrandForeground1} />
                <Badge
                  appearance="tint"
                  color="brand"
                  size="small"
                >
                  AI-enhanced
                </Badge>
              </div>
            )}
          </div>
        </DialogTitle>

        <DialogBody>
          {isLoading ? (
            <div className={styles.loadingContainer}>
              <Spinner size="medium" label="Loading briefing…" />
            </div>
          ) : (
            <>
              {fetchError && (
                <Text size={100} className={styles.errorText}>
                  {fetchError}
                </Text>
              )}
              <BriefingContent
                sections={narrative.sections}
                headline={narrative.headline}
                isAiEnhanced={isAiEnhanced}
                generatedAt={generatedAt}
              />
            </>
          )}
        </DialogBody>

        <DialogActions>
          <Button appearance="primary" onClick={onClose}>
            Close
          </Button>
        </DialogActions>
      </DialogSurface>
    </Dialog>
  );
};

BriefingDialog.displayName = "BriefingDialog";

// Default export enables React.lazy() dynamic import for bundle-size optimization (Task 033).
// Named export BriefingDialog above is preserved for direct imports in tests.
export default BriefingDialog;
