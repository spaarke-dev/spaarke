using System.Text.Json;
using OpenAI.Chat;
using Sprk.Bff.Api.Services.Ai.Prompts;

namespace Sprk.Bff.Api.Services.Ai.Builder;

/// <summary>
/// Result of the agentic builder loop.
/// Contains both the AI's message and any canvas operations to apply.
/// </summary>
public record BuilderAgentResult
{
    /// <summary>The AI's response message to the user.</summary>
    public required string Message { get; init; }

    /// <summary>Canvas operations generated by tool execution.</summary>
    public IReadOnlyList<CanvasOperation> CanvasOperations { get; init; } = [];

    /// <summary>Number of tool calls made during the conversation.</summary>
    public int ToolCallCount { get; init; }

    /// <summary>Whether the agent completed successfully.</summary>
    public bool Success { get; init; } = true;

    /// <summary>Error message if the agent failed.</summary>
    public string? Error { get; init; }
}

/// <summary>
/// Orchestrates the AI Playbook Builder agentic loop.
/// Handles multi-turn conversations with function calling for canvas operations.
///
/// This service implements the "Claude Code for Playbooks" pattern where the AI:
/// 1. Receives user requests
/// 2. Has full awareness of the canvas state and available scopes
/// 3. Can call tools to manipulate the canvas
/// 4. Continues the loop until the task is complete
/// </summary>
public class BuilderAgentService : IBuilderAgentService
{
    private readonly IOpenAiClient _openAiClient;
    private readonly IScopeResolverService _scopeResolver;
    private readonly BuilderToolExecutor _toolExecutor;
    private readonly ILogger<BuilderAgentService> _logger;

    /// <summary>Maximum number of tool call rounds to prevent infinite loops.</summary>
    private const int MaxToolRounds = 10;

    /// <summary>Model to use for the builder agent.</summary>
    private const string DefaultModel = "gpt-4o";

    public BuilderAgentService(
        IOpenAiClient openAiClient,
        IScopeResolverService scopeResolver,
        BuilderToolExecutor toolExecutor,
        ILogger<BuilderAgentService> logger)
    {
        _openAiClient = openAiClient;
        _scopeResolver = scopeResolver;
        _toolExecutor = toolExecutor;
        _logger = logger;
    }

    /// <summary>
    /// Execute the agentic loop for a user message.
    /// </summary>
    /// <param name="userMessage">The user's natural language request.</param>
    /// <param name="canvasState">Current state of the playbook canvas.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Result containing AI message and canvas operations.</returns>
    public async Task<BuilderAgentResult> ExecuteAsync(
        string userMessage,
        CanvasState canvasState,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation(
            "Starting builder agent for message: {MessagePreview}, NodeCount: {NodeCount}",
            userMessage.Length > 50 ? userMessage[..50] + "..." : userMessage,
            canvasState.Nodes.Length);

        try
        {
            // Build the conversation messages
            var messages = await BuildInitialMessagesAsync(userMessage, canvasState, cancellationToken);

            // Get all available tools
            var tools = BuilderToolDefinitions.GetAllTools();

            // Track all canvas operations across tool calls
            var allCanvasOperations = new List<CanvasOperation>();
            var toolCallCount = 0;

            // Create a mutable working state for tracking changes during the loop
            var workingState = CreateMutableWorkingState(canvasState);

            // Agentic loop: keep calling until model returns content without tool calls
            for (var round = 0; round < MaxToolRounds; round++)
            {
                var result = await _openAiClient.GetChatCompletionWithToolsAsync(
                    messages,
                    tools,
                    DefaultModel,
                    cancellationToken);

                // If no tool calls, we're done - return the content
                if (!result.HasToolCalls)
                {
                    _logger.LogInformation(
                        "Agent completed after {Rounds} rounds, {ToolCalls} tool calls",
                        round + 1, toolCallCount);

                    return new BuilderAgentResult
                    {
                        Message = result.Content ?? "I've made the requested changes to the playbook.",
                        CanvasOperations = allCanvasOperations,
                        ToolCallCount = toolCallCount,
                        Success = true
                    };
                }

                // Process each tool call
                toolCallCount += result.ToolCalls.Count;
                _logger.LogDebug(
                    "Round {Round}: Processing {ToolCallCount} tool calls",
                    round + 1, result.ToolCalls.Count);

                // Add assistant message with tool calls to conversation
                var assistantMessage = new AssistantChatMessage(result.ToolCalls);
                messages.Add(assistantMessage);

                // Execute each tool and add results to conversation
                foreach (var toolCall in result.ToolCalls)
                {
                    var toolResult = await ExecuteToolCallAsync(toolCall, canvasState, cancellationToken);

                    // Collect canvas operations
                    if (toolResult.CanvasOperations != null)
                    {
                        allCanvasOperations.AddRange(toolResult.CanvasOperations);

                        // Update working state for subsequent calls
                        ApplyOperationsToWorkingState(toolResult.CanvasOperations, workingState);
                    }

                    // Add tool result to conversation (serialize Result to JSON string)
                    var resultJson = toolResult.Success
                        ? (toolResult.Result?.RootElement.ToString() ?? "{\"success\": true}")
                        : JsonSerializer.Serialize(new { success = false, error = toolResult.Error });

                    var toolMessage = new ToolChatMessage(toolCall.Id, resultJson);
                    messages.Add(toolMessage);
                }
            }

            // Exceeded max rounds - return what we have
            _logger.LogWarning("Builder agent exceeded max rounds ({MaxRounds})", MaxToolRounds);

            return new BuilderAgentResult
            {
                Message = "I've completed the changes to the playbook. Please review the results.",
                CanvasOperations = allCanvasOperations,
                ToolCallCount = toolCallCount,
                Success = true
            };
        }
        catch (OpenAiCircuitBrokenException ex)
        {
            _logger.LogWarning(ex, "OpenAI circuit breaker open during builder agent execution");
            return new BuilderAgentResult
            {
                Message = "I'm temporarily unable to process your request due to high load. Please try again in a moment.",
                Success = false,
                Error = "Service temporarily unavailable"
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Builder agent execution failed");
            return new BuilderAgentResult
            {
                Message = "I encountered an error while processing your request. Please try again.",
                Success = false,
                Error = ex.Message
            };
        }
    }

    /// <summary>
    /// Build the initial conversation messages with system prompt and user request.
    /// </summary>
    private async Task<List<ChatMessage>> BuildInitialMessagesAsync(
        string userMessage,
        CanvasState canvasState,
        CancellationToken cancellationToken)
    {
        // Get the system prompt with scope catalog
        var systemPrompt = await BuildSystemPromptAsync(cancellationToken);

        // Build canvas context for the user message
        var canvasContext = BuildCanvasContextString(canvasState);

        var userPrompt = $"""
            ## User Request
            {userMessage}

            ## Current Canvas State
            {canvasContext}

            ## Task
            Help the user with their request. Use the available tools to manipulate the playbook canvas.
            After completing the requested changes, provide a brief summary of what you did.
            """;

        return new List<ChatMessage>
        {
            new SystemChatMessage(systemPrompt),
            new UserChatMessage(userPrompt)
        };
    }

    /// <summary>
    /// Build the system prompt including the scope catalog.
    /// </summary>
    private async Task<string> BuildSystemPromptAsync(CancellationToken cancellationToken)
    {
        // Get available scopes for the catalog using List methods
        var defaultOptions = new ScopeListOptions { PageSize = 50 };

        var actionsResult = await _scopeResolver.ListActionsAsync(defaultOptions, cancellationToken);
        var skillsResult = await _scopeResolver.ListSkillsAsync(defaultOptions, cancellationToken);
        var knowledgeResult = await _scopeResolver.ListKnowledgeAsync(defaultOptions, cancellationToken);

        // Build the system prompt with scope catalog
        return PlaybookBuilderSystemPrompt.Build(
            actionsResult.Items.Select(a => new ScopeCatalogEntry
            {
                Name = a.Name,
                DisplayName = a.Name, // AnalysisAction doesn't have DisplayName, use Name
                Description = a.Description ?? string.Empty,
                ScopeType = "action"
            }).ToList(),
            skillsResult.Items.Select(s => new ScopeCatalogEntry
            {
                Name = s.Name,
                DisplayName = s.Name, // AnalysisSkill doesn't have DisplayName, use Name
                Description = s.Description ?? string.Empty,
                ScopeType = "skill"
            }).ToList(),
            knowledgeResult.Items.Select(k => new ScopeCatalogEntry
            {
                Name = k.Name,
                DisplayName = k.Name, // AnalysisKnowledge doesn't have DisplayName, use Name
                Description = k.Description ?? string.Empty,
                ScopeType = "knowledge"
            }).ToList());
    }

    /// <summary>
    /// Build a string representation of the canvas state for context.
    /// </summary>
    private static string BuildCanvasContextString(CanvasState canvasState)
    {
        if (canvasState.Nodes.Length == 0)
        {
            return "The canvas is empty. No nodes or edges exist yet.";
        }

        var nodeList = string.Join("\n", canvasState.Nodes.Select(n =>
            $"  - {n.Id}: {n.Type} node \"{n.Label}\" at ({n.Position?.X ?? 0:F0}, {n.Position?.Y ?? 0:F0})"));

        var edgeList = canvasState.Edges.Length > 0
            ? string.Join("\n", canvasState.Edges.Select(e =>
                $"  - {e.Id}: {e.SourceId} â†’ {e.TargetId}" + (!string.IsNullOrEmpty(e.EdgeType) ? $" ({e.EdgeType})" : "")))
            : "  (no edges)";

        return $"""
            Nodes ({canvasState.Nodes.Length}):
            {nodeList}

            Edges ({canvasState.Edges.Length}):
            {edgeList}
            """;
    }

    /// <summary>
    /// Execute a single tool call and return the result.
    /// </summary>
    private async Task<BuilderToolResult> ExecuteToolCallAsync(
        ChatToolCall toolCall,
        CanvasState canvasState,
        CancellationToken cancellationToken)
    {
        _logger.LogDebug(
            "Executing tool call: {ToolName}, Id: {ToolCallId}",
            toolCall.FunctionName,
            toolCall.Id);

        // Parse the tool call - convert OpenAI types to our types
        var argumentsString = toolCall.FunctionArguments.ToString();
        var arguments = JsonDocument.Parse(argumentsString);

        var builderToolCall = new BuilderToolCall
        {
            Id = toolCall.Id,
            ToolName = toolCall.FunctionName,
            Arguments = arguments,
            RawArguments = argumentsString
        };

        // Execute and return result
        return await _toolExecutor.ExecuteAsync(builderToolCall, canvasState, cancellationToken);
    }

    /// <summary>
    /// Create a mutable working state from the initial canvas state.
    /// This allows tracking changes during the agent loop.
    /// </summary>
    private static WorkingCanvasState CreateMutableWorkingState(CanvasState canvasState)
    {
        return new WorkingCanvasState
        {
            Nodes = canvasState.Nodes.ToList(),
            Edges = canvasState.Edges.ToList()
        };
    }

    /// <summary>
    /// Apply canvas operations to the working state for tracking changes.
    /// </summary>
    private static void ApplyOperationsToWorkingState(
        IReadOnlyList<CanvasOperation> operations,
        WorkingCanvasState workingState)
    {
        foreach (var operation in operations)
        {
            try
            {
                switch (operation.Type)
                {
                    case CanvasOperationType.AddNode:
                        // Deserialize node from payload
                        var addNode = operation.Payload.Deserialize<CanvasNode>();
                        if (addNode != null)
                        {
                            workingState.Nodes.Add(addNode);
                        }
                        break;

                    case CanvasOperationType.RemoveNode:
                        // Extract nodeId from payload
                        if (operation.Payload.RootElement.TryGetProperty("nodeId", out var nodeIdElement))
                        {
                            var nodeId = nodeIdElement.GetString();
                            workingState.Nodes.RemoveAll(n => n.Id == nodeId);
                            workingState.Edges.RemoveAll(e => e.SourceId == nodeId || e.TargetId == nodeId);
                        }
                        break;

                    case CanvasOperationType.AddEdge:
                        // Deserialize edge from payload
                        var addEdge = operation.Payload.Deserialize<CanvasEdge>();
                        if (addEdge != null)
                        {
                            workingState.Edges.Add(addEdge);
                        }
                        break;

                    case CanvasOperationType.RemoveEdge:
                        // Extract edgeId from payload
                        if (operation.Payload.RootElement.TryGetProperty("edgeId", out var edgeIdElement))
                        {
                            var edgeId = edgeIdElement.GetString();
                            workingState.Edges.RemoveAll(e => e.Id == edgeId);
                        }
                        break;

                    case CanvasOperationType.UpdateNode:
                        // Extract nodeId and updates from payload
                        if (operation.Payload.RootElement.TryGetProperty("nodeId", out var updateNodeIdElement))
                        {
                            var nodeId = updateNodeIdElement.GetString();
                            var nodeIndex = workingState.Nodes.FindIndex(n => n.Id == nodeId);
                            if (nodeIndex >= 0 && operation.Payload.RootElement.TryGetProperty("updates", out var updatesElement))
                            {
                                var existingNode = workingState.Nodes[nodeIndex];
                                string? newLabel = existingNode.Label;

                                if (updatesElement.TryGetProperty("label", out var labelElement))
                                {
                                    newLabel = labelElement.GetString();
                                }

                                workingState.Nodes[nodeIndex] = existingNode with { Label = newLabel };
                            }
                        }
                        break;

                    case CanvasOperationType.UpdateLayout:
                    case CanvasOperationType.ValidateResult:
                        // These don't modify the working state directly
                        break;
                }
            }
            catch
            {
                // Ignore deserialization errors - working state is best-effort
            }
        }
    }

    /// <summary>
    /// Mutable working state for tracking canvas changes during agent loop.
    /// </summary>
    private class WorkingCanvasState
    {
        public List<CanvasNode> Nodes { get; init; } = new();
        public List<CanvasEdge> Edges { get; init; } = new();
    }
}

/// <summary>
/// Interface for the builder agent service.
/// </summary>
public interface IBuilderAgentService
{
    /// <summary>
    /// Execute the agentic loop for a user message.
    /// </summary>
    Task<BuilderAgentResult> ExecuteAsync(
        string userMessage,
        CanvasState canvasState,
        CancellationToken cancellationToken = default);
}
